{"version":3,"file":"property-set-weaving-strategy.js","sources":["../../../../../../src/weaver/jit/strategies/property-set-weaving-strategy.ts"],"sourcesContent":["import {\n    _JoinpointFactory,\n    AdviceType,\n    AfterAdvice,\n    AfterReturnAdvice,\n    AfterThrowAdvice,\n    AnnotationType,\n    AroundAdvice,\n    JoinPoint,\n    MutableAdviceContext,\n} from '@aspectjs/core/commons';\nimport { assert, isFunction } from '@aspectjs/core/utils';\nimport { _GenericWeavingStrategy } from './generic-weaving-strategy';\nimport { _PropertyGetWeavingStrategy } from './property-get-weaving-strategy';\n\n/**\n * @internal\n */\nexport class _PropertySetWeavingStrategy<T> extends _GenericWeavingStrategy<T, AdviceType.PROPERTY> {\n    private compiledDescriptor: PropertyDescriptor;\n\n    constructor(private getterHooks: _PropertyGetWeavingStrategy<T>) {\n        super();\n    }\n\n    compile(\n        ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>,\n    ): AdviceType.PROPERTY extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor {\n        return (this.compiledDescriptor = this.getterHooks.compile(ctxt, null));\n    }\n\n    initialJoinpoint(ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>, refDescriptor: PropertyDescriptor): void {\n        assert(isFunction(refDescriptor?.set));\n        ctxt.value = _JoinpointFactory.create(null, ctxt, refDescriptor.set)(ctxt.args);\n    }\n\n    around(\n        ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>,\n        advices: AroundAdvice<T, AdviceType.PROPERTY>[],\n        jp: JoinPoint<T>,\n    ): JoinPoint<T> {\n        return super.around(ctxt, advices, jp, false);\n    }\n\n    afterReturn(\n        ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>,\n        advices: AfterReturnAdvice<T, AdviceType.PROPERTY>[],\n    ): any {\n        return this._applyNonReturningAdvices(ctxt, advices);\n    }\n\n    afterThrow(\n        ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>,\n        advices: AfterThrowAdvice<T, AdviceType.PROPERTY>[],\n    ): any {\n        super.afterThrow(ctxt, advices, false);\n    }\n\n    after(ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>, advices: AfterAdvice<T, AdviceType.PROPERTY>[]): void {\n        this._applyNonReturningAdvices(ctxt, advices);\n    }\n\n    finalize(\n        ctxt: MutableAdviceContext<T, AnnotationType.PROPERTY>,\n        joinpoint: (...args: any[]) => T,\n    ): AnnotationType.PROPERTY extends AnnotationType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor {\n        const newDescriptor = {\n            ...this.compiledDescriptor,\n            set: joinpoint,\n        };\n\n        // test property validity\n        Object.getOwnPropertyDescriptor(Object.defineProperty({}, 'surrogate', newDescriptor), 'surrogate');\n\n        return newDescriptor;\n    }\n}\n"],"names":[],"mappings":";;;;AAeA;;;MAGa,2BAA+B,SAAQ,uBAA+C;IAG/F,YAAoB,WAA2C;QAC3D,KAAK,EAAE,CAAC;QADQ,gBAAW,GAAX,WAAW,CAAgC;KAE9D;IAED,OAAO,CACH,IAAkD;QAElD,QAAQ,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE;KAC3E;IAED,gBAAgB,CAAC,IAAkD,EAAE,aAAiC;QAClG,MAAM,CAAC,UAAU,CAAC,aAAa,aAAb,aAAa,uBAAb,aAAa,CAAE,GAAG,CAAC,CAAC,CAAC;QACvC,IAAI,CAAC,KAAK,GAAG,iBAAiB,CAAC,MAAM,CAAC,IAAI,EAAE,IAAI,EAAE,aAAa,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KACnF;IAED,MAAM,CACF,IAAkD,EAClD,OAA+C,EAC/C,EAAgB;QAEhB,OAAO,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;KACjD;IAED,WAAW,CACP,IAAkD,EAClD,OAAoD;QAEpD,OAAO,IAAI,CAAC,yBAAyB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACxD;IAED,UAAU,CACN,IAAkD,EAClD,OAAmD;QAEnD,KAAK,CAAC,UAAU,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;KAC1C;IAED,KAAK,CAAC,IAAkD,EAAE,OAA8C;QACpG,IAAI,CAAC,yBAAyB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KACjD;IAED,QAAQ,CACJ,IAAsD,EACtD,SAAgC;QAEhC,MAAM,aAAa,mCACZ,IAAI,CAAC,kBAAkB,KAC1B,GAAG,EAAE,SAAS,GACjB,CAAC;;QAGF,MAAM,CAAC,wBAAwB,CAAC,MAAM,CAAC,cAAc,CAAC,EAAE,EAAE,WAAW,EAAE,aAAa,CAAC,EAAE,WAAW,CAAC,CAAC;QAEpG,OAAO,aAAa,CAAC;KACxB;;;;;"}