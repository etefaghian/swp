{"version":3,"file":"annotation-target.factory.js","sources":["../../../../../../commons/src/annotation/target/annotation-target.factory.ts"],"sourcesContent":["import {\n    _getReferenceConstructor,\n    assert,\n    getOrComputeMetadata,\n    getProto,\n    isFunction,\n    isNumber,\n    isObject,\n    isUndefined,\n    locator,\n    Mutable,\n} from '@aspectjs/core/utils';\nimport { AdviceType } from '../../advices/types';\nimport { AnnotationType } from '../annotation.types';\nimport { AnnotationLocation, MethodAnnotationLocation } from '../location/annotation-location';\nimport {\n    AdviceTarget,\n    ClassAdviceTarget,\n    MethodAdviceTarget,\n    ParameterAdviceTarget,\n    PropertyAdviceTarget,\n} from './annotation-target';\n\nlet _globalTargetId = 0;\n/**\n * @public\n */\nexport class AnnotationTargetFactory {\n    private readonly _TARGET_GENERATORS = {\n        [AdviceType.CLASS]: _createClassAnnotationTarget,\n        [AdviceType.PROPERTY]: _createPropertyAnnotationTarget,\n        [AdviceType.METHOD]: _createMethodAnnotationTarget,\n        [AdviceType.PARAMETER]: _createParameterAnnotationTarget,\n    };\n\n    private readonly _REF_GENERATORS = {\n        [AdviceType.CLASS]: (d: Mutable<Partial<ClassAdviceTarget<any>>>) => {\n            const ref = `c[${_getReferenceConstructor(d.proto).name}]`;\n\n            return `${ref}#${getOrComputeMetadata('aspectjs.targetId', d.proto, () => _globalTargetId++)}`;\n        },\n        [AdviceType.PROPERTY]: (d: Mutable<Partial<PropertyAdviceTarget<any>>>) => {\n            return `${this._REF_GENERATORS[AdviceType.CLASS](d as any)}.p[${d.propertyKey}]`;\n        },\n        [AdviceType.METHOD]: (d: Mutable<Partial<MethodAdviceTarget<any>>>) => {\n            return this._REF_GENERATORS[AdviceType.PROPERTY](d as any);\n        },\n        [AdviceType.PARAMETER]: (d: Mutable<Partial<ParameterAdviceTarget<any>>>) => {\n            return `${this._REF_GENERATORS[AdviceType.METHOD](d as any)}.a[${\n                isNaN(d.parameterIndex) ? '*' : d.parameterIndex\n            }]`;\n        },\n    };\n\n    of<T, A extends AdviceType>(args: any[]): AdviceTarget<T, A> {\n        // ClassAnnotation = <TFunction extends Function>(target: TFunction) => TFunction | void;\n        // PropertyAnnotation = (target: Object, propertyKey: string | symbol) => void;\n        // MethodAnnotation = <A>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<A>) => TypedPropertyDescriptor<A> | void;\n        // ParameterAnnotation = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;\n\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        const target: Function | object = args[0];\n        const propertyKey: string | undefined = isUndefined(args[1]) ? undefined : String(args[1]);\n        const parameterIndex: number | undefined = isNumber(args[2]) ? args[2] : undefined;\n        const proto = getProto(target);\n        const descriptor: PropertyDescriptor | undefined = isObject(args[2]) ? args[2] : undefined;\n        const atarget: MutableAdviceTarget<any, AdviceType> = {\n            proto,\n            propertyKey,\n            parameterIndex,\n            descriptor,\n        };\n\n        return this.create(atarget as any);\n    }\n\n    /**\n     * Creates an AnnotationTarget from the given argument\n     * @param target - the AnnotationTarget stub.\n     * @param type - target type override\n     */\n    create<T, A extends AdviceType>(target: MutableAdviceTarget<T, A>, type?: AdviceType): AdviceTarget<T, A> {\n        // determine advice type\n        if (isUndefined(type) && isUndefined(target.type)) {\n            if (isNumber(((target as any) as ParameterAdviceTarget<T>).parameterIndex)) {\n                type = AdviceType.PARAMETER;\n            } else if (!isUndefined(target.propertyKey)) {\n                if (isObject(target.descriptor) && isFunction(target.descriptor.value)) {\n                    type = AdviceType.METHOD;\n                } else {\n                    type = AdviceType.PROPERTY;\n                }\n            } else {\n                type = AdviceType.CLASS;\n            }\n        } else {\n            type = type ?? target.type;\n        }\n\n        const ref = this._REF_GENERATORS[type](target as any);\n        target.type = type as A;\n        return getOrComputeMetadata(_metaKey(ref), target.proto, () => {\n            const t = (this._TARGET_GENERATORS[type] as any)(this, target as any, this._REF_GENERATORS[type]);\n            Reflect.setPrototypeOf(t, AnnotationTargetImpl.prototype);\n\n            return t;\n        }) as any;\n    }\n}\n\nfunction _metaKey(ref: string): string {\n    return `Decorizer.target:${ref}`;\n}\n\nclass AnnotationTargetImpl {\n    toString() {\n        return ((this as any) as AdviceTarget<any, any>).ref;\n    }\n}\n\n/**\n * @public\n */\nexport type MutableAdviceTarget<T, A extends AdviceType> = Mutable<Partial<AdviceTarget<T, A>>>;\n\nfunction _createClassAnnotationTarget<T, A extends AdviceType.CLASS>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, A>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, A> {\n    target = _createAnnotationTarget(target, AdviceType.CLASS, ['proto'], refGenerator) as Mutable<\n        Partial<AdviceTarget<T, A>>\n    >;\n    target.label = `class \"${target.proto.constructor.name}\"`;\n    target.name = target.proto.constructor.name;\n    target.declaringClass = target as any;\n\n    target.location = target.location ?? _createLocation(target);\n\n    const parentClass = _parentClassTargetProperty(targetFactory, target);\n    Object.defineProperties(target, {\n        parent: parentClass,\n        parentClass,\n    });\n\n    return target as AdviceTarget<T, A>;\n}\n\nfunction _createMethodAnnotationTarget<T, D extends AdviceType.METHOD>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, D>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    target = _createAnnotationTarget(target, AdviceType.METHOD, ['proto', 'propertyKey', 'descriptor'], refGenerator);\n\n    target.label = `method \"${target.proto.constructor.name}.${String(target.propertyKey)}\"`;\n    target.name = target.propertyKey;\n    Object.defineProperties(target, {\n        declaringClass: _declaringClassTargetProperty(targetFactory, target),\n        parent: _declaringClassTargetProperty(targetFactory, target),\n        parentClass: _parentClassTargetProperty(targetFactory, target),\n    });\n\n    if (!target.location) {\n        target.location = locator(_getDeclaringClassLocation(target) as any)\n            .at(target.propertyKey)\n            .orElseCompute(() => _createLocation(target) as MethodAnnotationLocation<T>);\n\n        target.location.args = _createAllParametersAnnotationTarget(targetFactory, target, refGenerator)\n            .location as any;\n    }\n\n    return target as AdviceTarget<T, D>;\n}\n\nfunction _getDeclaringClassLocation<T>(target: AnnotationTargetLike<T, AnnotationType>): AnnotationLocation<T> {\n    // retrieve the declaringClass location (location of the declaringClass target)\n    return locator(target.declaringClass)\n        .at('location')\n        .orElseCompute(() => _createLocation(target.declaringClass)); // if no rootLocation exists, create a new one.\n}\n\nfunction _createPropertyAnnotationTarget<T, D extends AdviceType.PROPERTY>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, D>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    target = _createAnnotationTarget(target, AdviceType.PROPERTY, ['proto', 'propertyKey'], refGenerator);\n\n    target.label = `property \"${target.proto.constructor.name}.${String(target.propertyKey)}\"`;\n    Object.defineProperties(target, {\n        declaringClass: _declaringClassTargetProperty(targetFactory, target),\n        parent: _declaringClassTargetProperty(targetFactory, target),\n        parentClass: _parentClassTargetProperty(targetFactory, target),\n    });\n\n    assert(target.type === AdviceType.PROPERTY);\n    target.location =\n        target.location ??\n        locator(_getDeclaringClassLocation<T>(target) as any)\n            .at(target.propertyKey)\n            .orElseCompute(() => _createLocation(target));\n\n    return target as AdviceTarget<T, D>;\n}\n\nfunction _createAllParametersAnnotationTarget<T, D extends AdviceType.PARAMETER | AdviceType.METHOD>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, D>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    target = _createAnnotationTarget<T, D>(\n        { ...target, parameterIndex: NaN as any },\n        AdviceType.PARAMETER,\n        ['parameterIndex', 'proto', 'propertyKey'],\n        refGenerator,\n    );\n    target.label = `parameter \"${target.proto.constructor.name}.${String(target.propertyKey)}(*)})\"`;\n    Object.defineProperties(target, {\n        declaringClass: _declaringClassTargetProperty(targetFactory, target),\n        parent: _declaringMethodTargetProperty(targetFactory, target),\n        parentClass: _parentClassTargetProperty(targetFactory, target),\n    });\n    target.location = target.location ?? _createLocation(target, []);\n    return target;\n}\nfunction _createParameterAnnotationTarget<T, D extends AdviceType.PARAMETER>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, D>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    target = _createAnnotationTarget<T, D>(\n        target,\n        AdviceType.PARAMETER,\n        ['parameterIndex', 'proto', 'propertyKey'],\n        refGenerator,\n    );\n    target.label = `parameter \"${target.proto.constructor.name}.${String(target.propertyKey)}(#${\n        target.parameterIndex\n    })\"`;\n    Object.defineProperties(target, {\n        declaringClass: _declaringClassTargetProperty(targetFactory, target),\n        parent: _declaringMethodTargetProperty(targetFactory, target),\n        parentClass: _parentClassTargetProperty(targetFactory, target),\n    });\n    if (!target.location) {\n        const methodLocation = locator(_getDeclaringClassLocation(target) as any)\n            .at(target.propertyKey)\n            .orElseCompute(() => {\n                return targetFactory.create(\n                    {\n                        proto: target.proto,\n                        propertyKey: target.propertyKey,\n                        descriptor: Object.getOwnPropertyDescriptor(target.proto, target.propertyKey) as any,\n                    },\n                    AdviceType.METHOD,\n                ).location;\n            });\n\n        target.location = locator(methodLocation.args)\n            .at(((target as any) as ParameterAdviceTarget<T>).parameterIndex)\n            .orElseCompute(() => _createLocation(target));\n    }\n    target.descriptor = Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey) as any;\n\n    return target;\n}\n\nfunction _createAnnotationTarget<T, D extends AdviceType>(\n    target: AnnotationTargetLike<T, D>,\n    type: AdviceType,\n    requiredProperties: (keyof AdviceTarget<T, D>)[],\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    requiredProperties.forEach((n) => assert(!isUndefined(target[n]), `target.${n} is undefined`));\n\n    target = { ...target };\n\n    // delete useleff properties\n    Object.keys(target)\n        .filter((p) => requiredProperties.indexOf(p as any) < 0)\n        .forEach((n: keyof AnnotationTargetLike<T, D>) => delete target[n]);\n\n    target.type = type as any;\n    target.ref = target.ref ?? refGenerator(target);\n\n    return target as AdviceTarget<T, D>;\n}\n\ntype AnnotationTargetLike<T, D extends AdviceType> = Mutable<Partial<AdviceTarget<T, D>>>;\n\nfunction _parentClassTargetProperty(\n    targetFactory: AnnotationTargetFactory,\n    dtarget: Partial<AdviceTarget<any, AdviceType>>,\n): PropertyDescriptor {\n    return {\n        get() {\n            const parentProto = Reflect.getPrototypeOf(dtarget.proto);\n            return parentProto === Object.prototype\n                ? undefined\n                : (targetFactory.of([parentProto]) as ClassAdviceTarget<any>);\n        },\n    } as PropertyDescriptor;\n}\n\nfunction _declaringClassTargetProperty(\n    targetFactory: AnnotationTargetFactory,\n    dtarget: Partial<AdviceTarget<any, AdviceType>>,\n): PropertyDescriptor {\n    return {\n        get() {\n            return targetFactory.create({ ...dtarget }, AdviceType.CLASS);\n        },\n    } as PropertyDescriptor;\n}\n\nfunction _declaringMethodTargetProperty(\n    targetFactory: AnnotationTargetFactory,\n    dtarget: Partial<AdviceTarget<any, AdviceType>>,\n): PropertyDescriptor {\n    return {\n        get() {\n            return targetFactory.of([dtarget.proto, dtarget.propertyKey]) as any;\n        },\n    } as PropertyDescriptor;\n}\n\nfunction _createLocation<T, A extends AnnotationType>(\n    target: Partial<AdviceTarget<T, A>>,\n    locationStub: any = new AdviceLocationImpl(),\n): AnnotationLocation<T, A> {\n    const proto = Object.create(Reflect.getPrototypeOf(locationStub));\n    proto.getTarget = () => {\n        return target;\n    };\n\n    Reflect.setPrototypeOf(locationStub, proto);\n\n    return locationStub as AnnotationLocation<T, A>;\n}\n\nclass AdviceLocationImpl<T, D extends AdviceType> {\n    getTarget(): AdviceTarget<T, AdviceType> {\n        throw new Error('No target registered');\n    }\n}\n"],"names":["AdviceType"],"mappings":";;;AAuBA,IAAI,eAAe,GAAG,CAAC,CAAC;AACxB;;;MAGa,uBAAuB;IAApC;QACqB,uBAAkB,GAAG;YAClC,CAACA,cAAU,CAAC,KAAK,GAAG,4BAA4B;YAChD,CAACA,cAAU,CAAC,QAAQ,GAAG,+BAA+B;YACtD,CAACA,cAAU,CAAC,MAAM,GAAG,6BAA6B;YAClD,CAACA,cAAU,CAAC,SAAS,GAAG,gCAAgC;SAC3D,CAAC;QAEe,oBAAe,GAAG;YAC/B,CAACA,cAAU,CAAC,KAAK,GAAG,CAAC,CAA2C;gBAC5D,MAAM,GAAG,GAAG,KAAK,wBAAwB,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,CAAC;gBAE3D,OAAO,GAAG,GAAG,IAAI,oBAAoB,CAAC,mBAAmB,EAAE,CAAC,CAAC,KAAK,EAAE,MAAM,eAAe,EAAE,CAAC,EAAE,CAAC;aAClG;YACD,CAACA,cAAU,CAAC,QAAQ,GAAG,CAAC,CAA8C;gBAClE,OAAO,GAAG,IAAI,CAAC,eAAe,CAACA,cAAU,CAAC,KAAK,CAAC,CAAC,CAAQ,CAAC,MAAM,CAAC,CAAC,WAAW,GAAG,CAAC;aACpF;YACD,CAACA,cAAU,CAAC,MAAM,GAAG,CAAC,CAA4C;gBAC9D,OAAO,IAAI,CAAC,eAAe,CAACA,cAAU,CAAC,QAAQ,CAAC,CAAC,CAAQ,CAAC,CAAC;aAC9D;YACD,CAACA,cAAU,CAAC,SAAS,GAAG,CAAC,CAA+C;gBACpE,OAAO,GAAG,IAAI,CAAC,eAAe,CAACA,cAAU,CAAC,MAAM,CAAC,CAAC,CAAQ,CAAC,MACvD,KAAK,CAAC,CAAC,CAAC,cAAc,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,cACtC,GAAG,CAAC;aACP;SACJ,CAAC;KAwDL;IAtDG,EAAE,CAA0B,IAAW;;;;;;QAOnC,MAAM,MAAM,GAAsB,IAAI,CAAC,CAAC,CAAC,CAAC;QAC1C,MAAM,WAAW,GAAuB,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;QAC3F,MAAM,cAAc,GAAuB,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC;QACnF,MAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;QAC/B,MAAM,UAAU,GAAmC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC;QAC3F,MAAM,OAAO,GAAyC;YAClD,KAAK;YACL,WAAW;YACX,cAAc;YACd,UAAU;SACb,CAAC;QAEF,OAAO,IAAI,CAAC,MAAM,CAAC,OAAc,CAAC,CAAC;KACtC;;;;;;IAOD,MAAM,CAA0B,MAAiC,EAAE,IAAiB;;QAEhF,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;YAC/C,IAAI,QAAQ,CAAG,MAA2C,CAAC,cAAc,CAAC,EAAE;gBACxE,IAAI,GAAGA,cAAU,CAAC,SAAS,CAAC;aAC/B;iBAAM,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE;gBACzC,IAAI,QAAQ,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,UAAU,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;oBACpE,IAAI,GAAGA,cAAU,CAAC,MAAM,CAAC;iBAC5B;qBAAM;oBACH,IAAI,GAAGA,cAAU,CAAC,QAAQ,CAAC;iBAC9B;aACJ;iBAAM;gBACH,IAAI,GAAGA,cAAU,CAAC,KAAK,CAAC;aAC3B;SACJ;aAAM;YACH,IAAI,GAAG,IAAI,aAAJ,IAAI,cAAJ,IAAI,GAAI,MAAM,CAAC,IAAI,CAAC;SAC9B;QAED,MAAM,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,MAAa,CAAC,CAAC;QACtD,MAAM,CAAC,IAAI,GAAG,IAAS,CAAC;QACxB,OAAO,oBAAoB,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,KAAK,EAAE;YACrD,MAAM,CAAC,GAAI,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAS,CAAC,IAAI,EAAE,MAAa,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC;YAClG,OAAO,CAAC,cAAc,CAAC,CAAC,EAAE,oBAAoB,CAAC,SAAS,CAAC,CAAC;YAE1D,OAAO,CAAC,CAAC;SACZ,CAAQ,CAAC;KACb;CACJ;AAED,SAAS,QAAQ,CAAC,GAAW;IACzB,OAAO,oBAAoB,GAAG,EAAE,CAAC;AACrC,CAAC;AAED,MAAM,oBAAoB;IACtB,QAAQ;QACJ,OAAS,IAAuC,CAAC,GAAG,CAAC;KACxD;CACJ;AAOD,SAAS,4BAA4B,CACjC,aAAsC,EACtC,MAAkC,EAClC,YAA2D;;IAE3D,MAAM,GAAG,uBAAuB,CAAC,MAAM,EAAEA,cAAU,CAAC,KAAK,EAAE,CAAC,OAAO,CAAC,EAAE,YAAY,CAEjF,CAAC;IACF,MAAM,CAAC,KAAK,GAAG,UAAU,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,GAAG,CAAC;IAC1D,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC;IAC5C,MAAM,CAAC,cAAc,GAAG,MAAa,CAAC;IAEtC,MAAM,CAAC,QAAQ,SAAG,MAAM,CAAC,QAAQ,mCAAI,eAAe,CAAC,MAAM,CAAC,CAAC;IAE7D,MAAM,WAAW,GAAG,0BAA0B,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC;IACtE,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE;QAC5B,MAAM,EAAE,WAAW;QACnB,WAAW;KACd,CAAC,CAAC;IAEH,OAAO,MAA4B,CAAC;AACxC,CAAC;AAED,SAAS,6BAA6B,CAClC,aAAsC,EACtC,MAAkC,EAClC,YAA2D;IAE3D,MAAM,GAAG,uBAAuB,CAAC,MAAM,EAAEA,cAAU,CAAC,MAAM,EAAE,CAAC,OAAO,EAAE,aAAa,EAAE,YAAY,CAAC,EAAE,YAAY,CAAC,CAAC;IAElH,MAAM,CAAC,KAAK,GAAG,WAAW,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,IAAI,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC;IACzF,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,WAAW,CAAC;IACjC,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE;QAC5B,cAAc,EAAE,6BAA6B,CAAC,aAAa,EAAE,MAAM,CAAC;QACpE,MAAM,EAAE,6BAA6B,CAAC,aAAa,EAAE,MAAM,CAAC;QAC5D,WAAW,EAAE,0BAA0B,CAAC,aAAa,EAAE,MAAM,CAAC;KACjE,CAAC,CAAC;IAEH,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;QAClB,MAAM,CAAC,QAAQ,GAAG,OAAO,CAAC,0BAA0B,CAAC,MAAM,CAAQ,CAAC;aAC/D,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC;aACtB,aAAa,CAAC,MAAM,eAAe,CAAC,MAAM,CAAgC,CAAC,CAAC;QAEjF,MAAM,CAAC,QAAQ,CAAC,IAAI,GAAG,oCAAoC,CAAC,aAAa,EAAE,MAAM,EAAE,YAAY,CAAC;aAC3F,QAAe,CAAC;KACxB;IAED,OAAO,MAA4B,CAAC;AACxC,CAAC;AAED,SAAS,0BAA0B,CAAI,MAA+C;;IAElF,OAAO,OAAO,CAAC,MAAM,CAAC,cAAc,CAAC;SAChC,EAAE,CAAC,UAAU,CAAC;SACd,aAAa,CAAC,MAAM,eAAe,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC;AACrE,CAAC;AAED,SAAS,+BAA+B,CACpC,aAAsC,EACtC,MAAkC,EAClC,YAA2D;;IAE3D,MAAM,GAAG,uBAAuB,CAAC,MAAM,EAAEA,cAAU,CAAC,QAAQ,EAAE,CAAC,OAAO,EAAE,aAAa,CAAC,EAAE,YAAY,CAAC,CAAC;IAEtG,MAAM,CAAC,KAAK,GAAG,aAAa,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,IAAI,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC;IAC3F,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE;QAC5B,cAAc,EAAE,6BAA6B,CAAC,aAAa,EAAE,MAAM,CAAC;QACpE,MAAM,EAAE,6BAA6B,CAAC,aAAa,EAAE,MAAM,CAAC;QAC5D,WAAW,EAAE,0BAA0B,CAAC,aAAa,EAAE,MAAM,CAAC;KACjE,CAAC,CAAC;IAEH,MAAM,CAAC,MAAM,CAAC,IAAI,KAAKA,cAAU,CAAC,QAAQ,CAAC,CAAC;IAC5C,MAAM,CAAC,QAAQ,SACX,MAAM,CAAC,QAAQ,mCACf,OAAO,CAAC,0BAA0B,CAAI,MAAM,CAAQ,CAAC;SAChD,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC;SACtB,aAAa,CAAC,MAAM,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC;IAEtD,OAAO,MAA4B,CAAC;AACxC,CAAC;AAED,SAAS,oCAAoC,CACzC,aAAsC,EACtC,MAAkC,EAClC,YAA2D;;IAE3D,MAAM,GAAG,uBAAuB,iCACvB,MAAM,KAAE,cAAc,EAAE,GAAU,KACvCA,cAAU,CAAC,SAAS,EACpB,CAAC,gBAAgB,EAAE,OAAO,EAAE,aAAa,CAAC,EAC1C,YAAY,CACf,CAAC;IACF,MAAM,CAAC,KAAK,GAAG,cAAc,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,IAAI,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC;IACjG,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE;QAC5B,cAAc,EAAE,6BAA6B,CAAC,aAAa,EAAE,MAAM,CAAC;QACpE,MAAM,EAAE,8BAA8B,CAAC,aAAa,EAAE,MAAM,CAAC;QAC7D,WAAW,EAAE,0BAA0B,CAAC,aAAa,EAAE,MAAM,CAAC;KACjE,CAAC,CAAC;IACH,MAAM,CAAC,QAAQ,SAAG,MAAM,CAAC,QAAQ,mCAAI,eAAe,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;IACjE,OAAO,MAAM,CAAC;AAClB,CAAC;AACD,SAAS,gCAAgC,CACrC,aAAsC,EACtC,MAAkC,EAClC,YAA2D;IAE3D,MAAM,GAAG,uBAAuB,CAC5B,MAAM,EACNA,cAAU,CAAC,SAAS,EACpB,CAAC,gBAAgB,EAAE,OAAO,EAAE,aAAa,CAAC,EAC1C,YAAY,CACf,CAAC;IACF,MAAM,CAAC,KAAK,GAAG,cAAc,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,IAAI,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,KACpF,MAAM,CAAC,cACX,IAAI,CAAC;IACL,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE;QAC5B,cAAc,EAAE,6BAA6B,CAAC,aAAa,EAAE,MAAM,CAAC;QACpE,MAAM,EAAE,8BAA8B,CAAC,aAAa,EAAE,MAAM,CAAC;QAC7D,WAAW,EAAE,0BAA0B,CAAC,aAAa,EAAE,MAAM,CAAC;KACjE,CAAC,CAAC;IACH,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;QAClB,MAAM,cAAc,GAAG,OAAO,CAAC,0BAA0B,CAAC,MAAM,CAAQ,CAAC;aACpE,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC;aACtB,aAAa,CAAC;YACX,OAAO,aAAa,CAAC,MAAM,CACvB;gBACI,KAAK,EAAE,MAAM,CAAC,KAAK;gBACnB,WAAW,EAAE,MAAM,CAAC,WAAW;gBAC/B,UAAU,EAAE,MAAM,CAAC,wBAAwB,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,WAAW,CAAQ;aACvF,EACDA,cAAU,CAAC,MAAM,CACpB,CAAC,QAAQ,CAAC;SACd,CAAC,CAAC;QAEP,MAAM,CAAC,QAAQ,GAAG,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC;aACzC,EAAE,CAAG,MAA2C,CAAC,cAAc,CAAC;aAChE,aAAa,CAAC,MAAM,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC;KACrD;IACD,MAAM,CAAC,UAAU,GAAG,OAAO,CAAC,wBAAwB,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,WAAW,CAAQ,CAAC;IAE9F,OAAO,MAAM,CAAC;AAClB,CAAC;AAED,SAAS,uBAAuB,CAC5B,MAAkC,EAClC,IAAgB,EAChB,kBAAgD,EAChD,YAA2D;;IAE3D,kBAAkB,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,eAAe,CAAC,CAAC,CAAC;IAE/F,MAAM,qBAAQ,MAAM,CAAE,CAAC;;IAGvB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;SACd,MAAM,CAAC,CAAC,CAAC,KAAK,kBAAkB,CAAC,OAAO,CAAC,CAAQ,CAAC,GAAG,CAAC,CAAC;SACvD,OAAO,CAAC,CAAC,CAAmC,KAAK,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAExE,MAAM,CAAC,IAAI,GAAG,IAAW,CAAC;IAC1B,MAAM,CAAC,GAAG,SAAG,MAAM,CAAC,GAAG,mCAAI,YAAY,CAAC,MAAM,CAAC,CAAC;IAEhD,OAAO,MAA4B,CAAC;AACxC,CAAC;AAID,SAAS,0BAA0B,CAC/B,aAAsC,EACtC,OAA+C;IAE/C,OAAO;QACH,GAAG;YACC,MAAM,WAAW,GAAG,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAC1D,OAAO,WAAW,KAAK,MAAM,CAAC,SAAS;kBACjC,SAAS;kBACR,aAAa,CAAC,EAAE,CAAC,CAAC,WAAW,CAAC,CAA4B,CAAC;SACrE;KACkB,CAAC;AAC5B,CAAC;AAED,SAAS,6BAA6B,CAClC,aAAsC,EACtC,OAA+C;IAE/C,OAAO;QACH,GAAG;YACC,OAAO,aAAa,CAAC,MAAM,mBAAM,OAAO,GAAIA,cAAU,CAAC,KAAK,CAAC,CAAC;SACjE;KACkB,CAAC;AAC5B,CAAC;AAED,SAAS,8BAA8B,CACnC,aAAsC,EACtC,OAA+C;IAE/C,OAAO;QACH,GAAG;YACC,OAAO,aAAa,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,WAAW,CAAC,CAAQ,CAAC;SACxE;KACkB,CAAC;AAC5B,CAAC;AAED,SAAS,eAAe,CACpB,MAAmC,EACnC,eAAoB,IAAI,kBAAkB,EAAE;IAE5C,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC,CAAC;IAClE,KAAK,CAAC,SAAS,GAAG;QACd,OAAO,MAAM,CAAC;KACjB,CAAC;IAEF,OAAO,CAAC,cAAc,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;IAE5C,OAAO,YAAwC,CAAC;AACpD,CAAC;AAED,MAAM,kBAAkB;IACpB,SAAS;QACL,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;KAC3C;;;;;"}