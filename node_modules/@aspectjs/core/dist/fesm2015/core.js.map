{"version":3,"file":"core.js","sources":["../../src/aspect/aspect.registry.impl.ts","../../src/weaver/plan.factory.ts","../../src/weaver/utils.ts","../../src/weaver/jit/strategies/generic-weaving-strategy.ts","../../src/weaver/jit/strategies/class-weaving-strategy.ts","../../src/weaver/jit/strategies/method-weaving-strategy.ts","../../src/weaver/jit/strategies/parameter-weaving-strategy.ts","../../src/weaver/jit/strategies/property-get-weaving-strategy.ts","../../src/weaver/jit/strategies/property-set-weaving-strategy.ts","../../src/weaver/jit/jit-weaver.ts","../../src/weaver/weaver-context.impl.ts","../../src/core.ts"],"sourcesContent":["import { After, AfterReturn, AfterThrow, Around, Before, Compile, Order } from '@aspectjs/core/annotations';\nimport {\n    _AdviceFactory,\n    _getWeaverContext,\n    Advice,\n    AdvicesFilter,\n    AdvicesRegistry,\n    AdviceTarget,\n    AdviceType,\n    AnnotationContext,\n    AnnotationLocationFactory,\n    AspectsRegistry,\n    AspectType,\n    Pointcut,\n    PointcutExpression,\n    PointcutPhase,\n    WeaverContext,\n} from '@aspectjs/core/commons';\nimport { assert, assertIsAspect, locator } from '@aspectjs/core/utils';\n\n/**\n * Stores the aspects along with their advices.\n * @public\n */\nexport class AspectsRegistryImpl implements AspectsRegistry {\n    private readonly _advicesRegistryKey: string;\n    private _advicesRegistry: AdvicesRegistry = {\n        byPointcut: {},\n        byTarget: {},\n        byAspect: {},\n    };\n    private _dirty = true;\n    private readonly _aspectsToLoad: Set<AspectType> = new Set<AspectType>();\n    private readonly _loadedAspects: Set<AspectType> = new Set<AspectType>();\n\n    constructor(private _weaverContext: WeaverContext) {\n        this._advicesRegistryKey = `aspectjs.adviceRegistry.byAspects`; // TODO increment key with AspectsRegistry instance ?\n    }\n\n    /**\n     * Register a new advice, with the aspect it belongs to.\n     * @param aspects - The aspects to register\n     */\n    register(...aspects: AspectType[]): void {\n        (aspects ?? []).forEach((aspect) => {\n            // get annotations bundle\n            const annotationsContext = _getWeaverContext().annotations;\n            const bundle = annotationsContext.bundle.at(annotationsContext.location.of(aspect));\n\n            // get @Aspect options\n            const target = this._getTarget(aspect);\n\n            const byAspectRegistry = locator(this._advicesRegistry.byAspect)\n                .at(target.ref)\n                .orElseCompute(() => ({}));\n\n            this._aspectsToLoad.add(aspect);\n            [\n                [Compile, PointcutPhase.COMPILE],\n                [Before, PointcutPhase.BEFORE],\n                [Around, PointcutPhase.AROUND],\n                [After, PointcutPhase.AFTER],\n                [AfterReturn, PointcutPhase.AFTERRETURN],\n                [AfterThrow, PointcutPhase.AFTERTHROW],\n            ].forEach((adviceDef) => {\n                bundle.onMethod(adviceDef[0]).forEach((annotation) => {\n                    const expr = annotation.args[0] as PointcutExpression;\n                    assert(!!expr);\n\n                    const advice = _AdviceFactory.create(\n                        Pointcut.of(adviceDef[1] as PointcutPhase, expr),\n                        annotation.target,\n                    );\n                    const k = `${advice.pointcut.ref}=>${advice.name}`;\n                    byAspectRegistry[k] = advice;\n                });\n            });\n        });\n    }\n\n    remove(...aspects: AspectType[]): void {\n        this._dirty = true;\n        if (this._aspectsToLoad.size) {\n            aspects.forEach((a) => {\n                // remove aspect from the list of aspects to load\n                this._aspectsToLoad.delete(a);\n\n                // remove aspect from registry\n                delete this._advicesRegistry.byAspect[this._getTarget(a).ref];\n            });\n        }\n\n        // force all aspects to reload\n        this._loadedAspects.forEach((a) => this._aspectsToLoad.add(a));\n        this._loadedAspects.clear();\n    }\n\n    /**\n     * Get all advices that belongs to the given aspect\n     * @param aspect - the aspect to get advices for.\n     */\n    getAdvicesByAspect(aspect: AspectType): Advice[] {\n        assertIsAspect(aspect);\n        const target = this._getTarget(aspect);\n\n        return Object.values(this._advicesRegistry.byAspect[target.ref] ?? {})\n            .flat()\n            .map((advice) => {\n                const bound = advice.bind(aspect);\n                Object.defineProperties(bound, Object.getOwnPropertyDescriptors(advice));\n                return bound as Advice;\n            });\n    }\n\n    getAdvicesByTarget<T, A extends AdviceType, P extends PointcutPhase>(\n        target: AdviceTarget<T, A>,\n        filter?: AdvicesFilter,\n        ...phases: PointcutPhase[]\n    ): AdvicesRegistry['byTarget'][string] {\n        this._load();\n\n        const targetRegistry = locator(this._advicesRegistry)\n            .at('byTarget')\n            .at(`${target.ref}${filter?.name ? `:${filter?.name}` : ''}`)\n            .orElseGet(() => ({}));\n\n        // get all advices that correspond to all the annotations of this context\n        const bundle = this._weaverContext.annotations.bundle.at(target.location);\n        const annotationContexts: readonly AnnotationContext[] = bundle.onSelf();\n\n        (phases ?? []).forEach((phase) => {\n            if (!targetRegistry[phase]) {\n                let advices = annotationContexts\n                    .map((annotationContext) =>\n                        locator(this._advicesRegistry)\n                            .at('byPointcut')\n                            .at(phase)\n                            .at(target.type)\n                            .at('byAnnotation')\n                            .at(annotationContext.ref)\n                            .orElseGet(() => [] as any),\n                    )\n                    .flat()\n                    .sort((a1: Advice, a2: Advice) => {\n                        // sort by advice order\n                        const a = this._weaverContext.annotations;\n                        const o1 = a.bundle.at(a.location.of(a1.aspect as any)[a1.name]).onMethod(Order)[0]?.args[0];\n                        const o2 = a.bundle.at(a.location.of(a2.aspect as any)[a1.name]).onMethod(Order)[0]?.args[0];\n\n                        return _compareOrder(o1, o2);\n                    });\n\n                if (filter) {\n                    advices = advices.filter(filter.fn);\n                }\n                (targetRegistry as any)[phase] = advices;\n            }\n        });\n        return targetRegistry;\n    }\n    /**\n     * @internal\n     */\n    private _getTarget<T>(obj: T): AdviceTarget<T> {\n        return AnnotationLocationFactory.getTarget(this._weaverContext.annotations.location.of(obj));\n    }\n\n    /**\n     * Sort the aspects according to their precedence & store by target, by phase & type\n     * @private\n     */\n    private _load() {\n        if (this._dirty) {\n            this._advicesRegistry.byPointcut = {};\n            this._advicesRegistry.byTarget = {};\n        }\n        if (!this._aspectsToLoad.size) {\n            return;\n        }\n\n        [...this._aspectsToLoad]\n            .sort((a1: any, a2: any) => {\n                // sort by aspect order\n                const a = this._weaverContext.annotations;\n                const o1 = a.bundle.at(a.location.of(a1)).onClass(Order)[0]?.args[0];\n                const o2 = a.bundle.at(a.location.of(a2)).onClass(Order)[0]?.args[0];\n\n                return _compareOrder(o1, o2);\n            })\n            .map((a) => {\n                this._loadedAspects.add(a);\n                return a;\n            })\n            .map((aspect: AspectType) => this.getAdvicesByAspect(aspect))\n            .flat()\n            .forEach((advice: Advice) => {\n                const pc = advice.pointcut;\n                locator(this._advicesRegistry)\n                    .at('byPointcut')\n                    .at(pc.phase)\n                    .at(pc.type)\n                    .at('byAnnotation')\n                    .at(pc.annotation.ref)\n                    .orElseCompute(() => [])\n                    .push(advice);\n            });\n        this._dirty = false;\n        this._aspectsToLoad.clear();\n    }\n}\n\nfunction _compareOrder(o1: any, o2: any) {\n    if (o1 === Order.LOWEST_PRECEDENCE || o1 === undefined) {\n        return 1;\n    }\n\n    if (o2 === Order.LOWEST_PRECEDENCE || o2 === undefined) {\n        return -1;\n    }\n\n    if (o1 === Order.HIGHEST_PRECEDENCE) {\n        return -1;\n    }\n\n    if (o2 === Order.HIGHEST_PRECEDENCE) {\n        return 1;\n    }\n    return o1 - o2;\n}\n","import {\n    _getWeaverContext,\n    _JoinpointFactory,\n    Advice,\n    AdviceTarget,\n    AdviceType,\n    CompileAdvice,\n    MutableAdviceContext,\n    PointcutPhase,\n    WeaverContext,\n    WeavingError,\n} from '@aspectjs/core/commons';\nimport { assert } from '@aspectjs/core/utils';\nimport { _WeavingStrategy } from './weaving-strategy';\n\n/**\n * @internal\n */\nexport class _AdviceExecutionPlanFactory {\n    create<T, A extends AdviceType = any>(\n        target: AdviceTarget<T, A>,\n        hooks: _WeavingStrategy<T, A>,\n        filter?: {\n            name: string;\n            fn: (a: Advice) => boolean;\n        },\n    ): _ExecutionPlan<T, A> {\n        let compiled = false;\n        let compiledSymbol: A extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor;\n\n        const linkFn = (ctxt: MutableAdviceContext<T, A>) => {\n            if (!compiled) {\n                compileFn(ctxt);\n            }\n            assert(!!compiledSymbol);\n\n            const jp = function (...args: any[]): T {\n                ctxt.args = args;\n                ctxt.instance = this;\n                const advicesReg = _getWeaverContext().aspects.registry.getAdvicesByTarget(\n                    ctxt.target,\n                    filter,\n                    PointcutPhase.BEFORE,\n                    PointcutPhase.AROUND,\n                    PointcutPhase.AFTERRETURN,\n                    PointcutPhase.AFTERTHROW,\n                    PointcutPhase.AFTER,\n                );\n\n                // create the joinpoint for the original method\n                const jp = _JoinpointFactory.create(null, ctxt, (...args: any[]) => {\n                    const restoreJp = ctxt.joinpoint;\n                    const restoreArgs = ctxt.args;\n                    ctxt.args = args;\n                    delete ctxt.joinpoint;\n\n                    try {\n                        hooks.preBefore?.call(hooks, ctxt);\n                        hooks.before(ctxt, advicesReg[PointcutPhase.BEFORE] as Advice<T, A, PointcutPhase.BEFORE>[]);\n\n                        hooks.initialJoinpoint.call(hooks, ctxt, compiledSymbol);\n\n                        hooks.preAfterReturn?.call(hooks, ctxt);\n                        return hooks.afterReturn(\n                            ctxt,\n                            advicesReg[PointcutPhase.AFTERRETURN] as Advice<T, A, PointcutPhase.AFTERRETURN>[],\n                        );\n                    } catch (e) {\n                        // consider WeavingErrors as not recoverable by an aspect\n                        if (e instanceof WeavingError) {\n                            throw e;\n                        }\n                        ctxt.error = e;\n\n                        hooks.preAfterThrow?.call(hooks, ctxt);\n                        return hooks.afterThrow(\n                            ctxt,\n                            advicesReg[PointcutPhase.AFTERTHROW] as Advice<T, A, PointcutPhase.AFTERTHROW>[],\n                        );\n                    } finally {\n                        delete ctxt.error;\n                        hooks.preAfter?.call(hooks, ctxt);\n                        hooks.after(ctxt, advicesReg[PointcutPhase.AFTER] as Advice<T, A, PointcutPhase.AFTER>[]);\n                        ctxt.joinpoint = restoreJp;\n                        ctxt.args = restoreArgs;\n                    }\n                });\n\n                hooks.preAround?.call(hooks, ctxt);\n                return hooks.around(\n                    ctxt,\n                    advicesReg[PointcutPhase.AROUND] as Advice<T, A, PointcutPhase.AROUND>[],\n                    jp,\n                )(args);\n            };\n\n            return hooks.finalize.call(hooks, ctxt, jp) ?? jp;\n        };\n        const compileFn = (ctxt: MutableAdviceContext<T, A>) => {\n            const compileAdvices = _getWeaverContext().aspects.registry.getAdvicesByTarget(\n                ctxt.target,\n                filter,\n                PointcutPhase.COMPILE,\n            )[PointcutPhase.COMPILE];\n            compiledSymbol = hooks.compile(ctxt, compileAdvices as CompileAdvice<T, A>[]);\n            compiled = true;\n            if (!compiledSymbol) {\n                throw new WeavingError(\n                    `${Reflect.getPrototypeOf(hooks).constructor.name}.compile() did not returned a symbol`,\n                );\n            }\n            return compiledSymbol;\n        };\n        return new _ExecutionPlan<T, A>(compileFn, linkFn);\n    }\n}\n\ntype WeaverCompile<T = unknown, A extends AdviceType = any> = (\n    ctxt: MutableAdviceContext<T, A>,\n) => A extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor;\n\ntype WeaverLink<T = unknown, A extends AdviceType = any> = (\n    ctxt: MutableAdviceContext<T, A>,\n    initialSymbol: A extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor,\n) => A extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor;\n/**\n * Sort the advices according to their precedence & store by phase & type, so they are ready to execute.\n * @internal\n */\nexport class _ExecutionPlan<T = unknown, A extends AdviceType = any> {\n    constructor(private compileFn: WeaverCompile<T, A>, private linkFn: WeaverLink<T, A>) {}\n\n    compile<C extends MutableAdviceContext<T, A>>(\n        ctxt: C,\n    ): {\n        link: () => A extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor;\n    } {\n        const compiled = this.compileFn(ctxt);\n        const link = this.linkFn;\n        return {\n            /**\n             * Returns a function that executes the plan for the Before, Around, AfterReturn, AfterThrow & After advices.\n             */\n            link: () => link(ctxt, compiled),\n        };\n    }\n}\n","import { assert } from '@aspectjs/core/utils';\n\n/**\n *\n * @param fn\n * @param name\n * @param tag\n * @param toString\n * @internal\n */\nexport function _defineFunctionProperties<T, F extends (...args: any[]) => T>(\n    fn: F,\n    name: string,\n    tag: string,\n    toString: () => string,\n): F {\n    assert(typeof fn === 'function');\n\n    // const newFn = fn;\n    const newFn = new Function('fn', `return function ${name}(...args) { return fn.apply(this, args) };`)(fn);\n    Object.defineProperty(newFn, 'name', {\n        value: name,\n    });\n    tag = tag ?? name;\n\n    Object.defineProperty(newFn, Symbol.toPrimitive, {\n        enumerable: false,\n        configurable: true,\n        value: () => tag,\n    });\n\n    newFn.prototype.toString = toString;\n    newFn.toString = toString;\n    return newFn;\n}\n","import {\n    _JoinpointFactory,\n    Advice,\n    AdviceContext,\n    AdviceError,\n    AdviceType,\n    AfterAdvice,\n    AfterReturnAdvice,\n    AfterThrowAdvice,\n    AfterThrowContext,\n    AnnotationType,\n    AroundAdvice,\n    BeforeAdvice,\n    CompileAdvice,\n    JoinPoint,\n    MutableAdviceContext,\n} from '@aspectjs/core/commons';\nimport { assert, isUndefined } from '@aspectjs/core/utils';\nimport { _WeavingStrategy } from '../../weaving-strategy';\n\n/**\n * @internal\n */\nexport abstract class _GenericWeavingStrategy<T, A extends AdviceType> implements _WeavingStrategy<T, A> {\n    after(ctxt: MutableAdviceContext<T, A>, advices: AfterAdvice<T, A>[]): void {\n        this._applyNonReturningAdvices(ctxt, advices);\n    }\n\n    afterReturn(ctxt: MutableAdviceContext<T, A>, advices: AfterReturnAdvice<T, A>[]): T {\n        ctxt.value = ctxt.value; // force key 'value' to be present\n\n        advices.forEach((advice) => {\n            ctxt.value = advice(ctxt, ctxt.value);\n        });\n\n        return ctxt.value as T;\n    }\n\n    afterThrow(ctxt: MutableAdviceContext<T, A>, advices: AfterThrowAdvice<T, A>[], allowReturn = true): any {\n        if (advices.length) {\n            ctxt.value = ctxt.value ?? undefined; // force key 'value' to be present\n            advices.forEach((advice: AfterThrowAdvice) => {\n                ctxt.advice = advice as any;\n                ctxt.value = advice(ctxt as AfterThrowContext<any, AdviceType>, ctxt.error);\n                delete ctxt.advice;\n                if (!allowReturn && !isUndefined(ctxt.value)) {\n                    throw new AdviceError(advice, `Returning from advice is not supported`);\n                }\n            });\n            return ctxt.value;\n        } else {\n            assert(!!ctxt.error);\n            // pass-trough errors by default\n            throw ctxt.error;\n        }\n    }\n\n    around(\n        ctxt: MutableAdviceContext<T, A>,\n        advices: AroundAdvice<T, A>[],\n        jp: JoinPoint<T>,\n        allowReturn = true,\n    ): JoinPoint<T> {\n        advices.reverse().forEach((advice) => {\n            const originalJp = jp;\n            const nextJp = _JoinpointFactory.create(advice, ctxt, (...args: unknown[]) => originalJp(args));\n            jp = (args: any[]) => {\n                ctxt.joinpoint = nextJp;\n                ctxt.args = args;\n                ctxt.advice = advice;\n                ctxt.value = advice(ctxt as any, nextJp, args);\n                if (ctxt.value !== undefined && !allowReturn) {\n                    throw new AdviceError(advice, `Returning from advice is not supported`);\n                }\n                return ctxt.value as T;\n            };\n        });\n\n        return jp;\n    }\n\n    before(ctxt: MutableAdviceContext<T, A>, advices: BeforeAdvice<T, A>[]): void {\n        this._applyNonReturningAdvices(ctxt, advices);\n    }\n\n    abstract compile(\n        ctxt: MutableAdviceContext<T, A>,\n        advices: CompileAdvice<T, AdviceType>[],\n    ): A extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor;\n\n    abstract initialJoinpoint(\n        ctxt: MutableAdviceContext<T, A>,\n        originalSymbol: A extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor,\n    ): void;\n\n    abstract finalize(\n        ctxt: MutableAdviceContext<T, A>,\n        joinpoint: (...args: any[]) => T,\n    ): A extends AnnotationType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor;\n\n    protected _applyNonReturningAdvices(ctxt: MutableAdviceContext<any>, advices: Advice[]) {\n        advices.forEach((advice: AfterAdvice) => {\n            ctxt.advice = advice;\n            const retVal = advice(ctxt as AdviceContext);\n            delete ctxt.advice;\n            if (!isUndefined(retVal)) {\n                throw new AdviceError(advice, `Returning from advice is not supported`);\n            }\n        });\n    }\n}\n","import {\n    _JoinpointFactory,\n    AdviceContext,\n    AdviceType,\n    AfterReturnAdvice,\n    AfterThrowAdvice,\n    AroundAdvice,\n    AroundContext,\n    CompileAdvice,\n    JoinPoint,\n    MutableAdviceContext,\n} from '@aspectjs/core/commons';\nimport { _getReferenceConstructor, _setReferenceConstructor, assert, isUndefined, Mutable } from '@aspectjs/core/utils';\nimport { _defineFunctionProperties } from '../../utils';\nimport { _GenericWeavingStrategy } from './generic-weaving-strategy';\n\n/**\n * @internal\n */\nexport class _ClassWeavingStrategy<T> extends _GenericWeavingStrategy<T, AdviceType.CLASS> {\n    private originalInstance: T;\n\n    compile(\n        ctxt: MutableAdviceContext<T, AdviceType.CLASS>,\n        advices: CompileAdvice<T, AdviceType.CLASS>[],\n    ): AdviceType.CLASS extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor {\n        // if another @Compile advice has been applied\n        // replace wrapped ctor by original ctor before it gets wrapped again\n        ctxt.target.proto.constructor = _getReferenceConstructor(ctxt.target.proto);\n        _setReferenceConstructor(ctxt.target.proto, ctxt.target.proto.constructor);\n\n        let ctor: new (...args: any[]) => T;\n        advices.forEach((advice: CompileAdvice<T, AdviceType.CLASS>) => {\n            ctxt.advice = advice;\n            ctor = advice(ctxt as AdviceContext<T, AdviceType.CLASS>) as any;\n        });\n        delete ctxt.advice;\n        return (ctxt.target.proto.constructor = ctor ?? ctxt.target.proto.constructor);\n    }\n\n    preAround(ctxt: MutableAdviceContext<T, AdviceType.CLASS>) {\n        // original ctor invocation will discard any changes done to instance before, so accessing ctxt.instance is forbidden\n        this.originalInstance = ctxt.instance;\n        ctxt.instance = null;\n    }\n\n    around(\n        ctxt: Mutable<AroundContext<T, AdviceType.CLASS>>,\n        advices: AroundAdvice<T, AdviceType.CLASS>[],\n        joinpoint: JoinPoint<T>,\n    ): (args?: any[]) => any {\n        advices.reverse().forEach((advice) => {\n            const originalJp = joinpoint;\n            const nextJp = _JoinpointFactory.create(advice, ctxt, (...args: unknown[]) => originalJp(args));\n            joinpoint = (args: any[]) => {\n                ctxt.joinpoint = nextJp;\n                ctxt.args = args;\n                ctxt.advice = advice;\n                return (ctxt.instance = advice(ctxt as any, nextJp, args) ?? ctxt.instance);\n            };\n        });\n\n        return joinpoint;\n    }\n\n    initialJoinpoint(ctxt: MutableAdviceContext<T, AdviceType.CLASS>, originalCtor: { new (...args: any[]): T }): void {\n        // We need to keep originalInstance as the instance, because of instanceof.\n        // Merge the new instance into originalInstance;\n        Object.assign(this.originalInstance, new originalCtor(...ctxt.args) ?? this.originalInstance);\n        ctxt.instance = this.originalInstance;\n    }\n\n    afterReturn<T>(\n        ctxt: MutableAdviceContext<T, AdviceType.CLASS>,\n        advices: AfterReturnAdvice<T, AdviceType.CLASS>[],\n    ): T {\n        let newInstance = ctxt.instance;\n\n        advices.forEach((advice) => {\n            ctxt.value = ctxt.instance;\n            ctxt.advice = advice;\n            newInstance = advice(ctxt, ctxt.value);\n            if (!isUndefined(newInstance)) {\n                ctxt.instance = newInstance;\n            }\n            delete ctxt.advice;\n        });\n\n        return ctxt.instance;\n    }\n\n    preAfterThrow(ctxt: MutableAdviceContext<T, AdviceType.CLASS>): void {\n        // as of ES6 classes, 'this' is no more available after ctor thrown.\n        // replace 'this' with partial this\n        ctxt.instance = this.originalInstance;\n    }\n\n    afterThrow(ctxt: MutableAdviceContext<T, AdviceType.CLASS>, advices: AfterThrowAdvice<T, AdviceType.CLASS>[]): T {\n        if (!advices.length) {\n            // pass-trough errors by default\n            throw ctxt.error;\n        } else {\n            let newInstance = ctxt.instance;\n            advices.forEach((advice) => {\n                ctxt.advice = advice;\n                newInstance = advice(ctxt, ctxt.error);\n                if (!isUndefined(newInstance)) {\n                    ctxt.instance = newInstance;\n                }\n                delete ctxt.advice;\n            });\n            return ctxt.instance;\n        }\n    }\n\n    finalize(\n        ctxt: MutableAdviceContext<T, AdviceType.CLASS>,\n        joinpoint: (...args: any[]) => T,\n    ): new (...args: any[]) => T {\n        assert(!!ctxt.target?.proto);\n        const originalCtor = ctxt.target.proto.constructor;\n        const ctorName = originalCtor.name;\n\n        joinpoint = _defineFunctionProperties(\n            joinpoint,\n            ctorName,\n            `class ${ctorName}$$advised {}`,\n            originalCtor.toString.bind(originalCtor),\n        );\n        joinpoint.prototype = ctxt.target.proto;\n        joinpoint.prototype.constructor = joinpoint;\n\n        return joinpoint as any;\n    }\n}\n","import {\n    AdviceContext,\n    AdviceError,\n    AdviceType,\n    CompileAdvice,\n    JoinPoint,\n    MutableAdviceContext,\n} from '@aspectjs/core/commons';\nimport { getOrComputeMetadata, isFunction, isUndefined } from '@aspectjs/core/utils';\nimport { _defineFunctionProperties } from '../../utils';\nimport { _GenericWeavingStrategy } from './generic-weaving-strategy';\n\ntype MethodPropertyDescriptor = PropertyDescriptor & { value: (...args: any[]) => any };\n\n/**\n * @internal\n */\nexport class _MethodWeavingStrategy<T> extends _GenericWeavingStrategy<T, AdviceType.METHOD> {\n    compile(ctxt: MutableAdviceContext<T, AdviceType.METHOD>, advices: CompileAdvice<T, AdviceType.METHOD>[]) {\n        const target = ctxt.target;\n\n        // save & restore original descriptor\n        Reflect.defineProperty(\n            target.proto,\n            target.propertyKey,\n            getOrComputeMetadata(\n                'aspectjs.originalMethodDescriptor',\n                target.proto,\n                ctxt.target.propertyKey,\n                () => {\n                    return { ...Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey) };\n                },\n                true,\n            ),\n        );\n\n        let lastCompileAdvice = advices[0];\n        let newDescriptor: PropertyDescriptor;\n\n        advices.forEach((advice) => {\n            lastCompileAdvice = advice;\n            ctxt.advice = advice;\n            newDescriptor =\n                (advice(ctxt as AdviceContext<T, AdviceType.METHOD>) as PropertyDescriptor) ?? newDescriptor;\n        });\n        delete ctxt.advice;\n\n        if (isUndefined(newDescriptor)) {\n            return Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey) as MethodPropertyDescriptor;\n        } else {\n            if (Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey)?.configurable === false) {\n                throw new AdviceError(lastCompileAdvice, `${target.label} is not configurable`);\n            }\n\n            // ensure value is a function\n            if (!isFunction(newDescriptor.value)) {\n                throw new AdviceError(\n                    lastCompileAdvice,\n                    `Expected advice to return a method descriptor. Got: ${newDescriptor.value}`,\n                );\n            }\n\n            if (isUndefined(newDescriptor.enumerable)) {\n                newDescriptor.enumerable = false;\n            }\n            if (isUndefined(newDescriptor.configurable)) {\n                newDescriptor.configurable = true;\n            }\n            // test property validity\n            newDescriptor = Object.getOwnPropertyDescriptor(\n                Object.defineProperty({}, 'surrogate', newDescriptor),\n                'surrogate',\n            );\n\n            Reflect.defineProperty(target.proto, target.propertyKey, newDescriptor);\n            return newDescriptor as MethodPropertyDescriptor;\n        }\n    }\n\n    initialJoinpoint(ctxt: MutableAdviceContext<T, AdviceType.METHOD>, refDescriptor: PropertyDescriptor): void {\n        ctxt.value = refDescriptor.value.apply(ctxt.instance, ctxt.args);\n    }\n\n    finalize(ctxt: MutableAdviceContext<T, AdviceType.METHOD>, jp: JoinPoint): PropertyDescriptor {\n        const newDescriptor: PropertyDescriptor = Object.getOwnPropertyDescriptor(\n            ctxt.target.proto,\n            ctxt.target.propertyKey,\n        );\n\n        newDescriptor.value = jp;\n\n        const originalFn = ctxt.target.proto[ctxt.target.propertyKey];\n        newDescriptor.value = _defineFunctionProperties(\n            newDescriptor.value,\n            originalFn.name,\n            originalFn.toString().split('\\n')[0],\n            originalFn.toString.bind(originalFn),\n        );\n\n        Reflect.defineMetadata('aspectjs.enhancedMethodDescriptor', true, newDescriptor);\n        return newDescriptor;\n    }\n}\n","import { AnnotationType, CompileAdvice, MutableAdviceContext } from '@aspectjs/core/commons';\nimport { getOrComputeMetadata } from '@aspectjs/core/utils';\nimport { _MethodWeavingStrategy } from './method-weaving-strategy';\n\nconst _defineProperty = Object.defineProperty;\n\nexport class _ParameterWeavingStrategy<T> extends _MethodWeavingStrategy<T> {\n    constructor() {\n        super();\n    }\n\n    compile(\n        ctxt: MutableAdviceContext<T, AnnotationType.METHOD>,\n        advices: CompileAdvice<T, AnnotationType.METHOD>[],\n    ): PropertyDescriptor & { value: (...args: any[]) => any } {\n        const target = ctxt.target;\n        // save & restore original descriptor\n        const originalDescriptor = getOrComputeMetadata(\n            'aspectjs.originalPropertyDescriptor',\n            target.proto,\n            ctxt.target.propertyKey,\n            () => {\n                return { ...Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey) };\n            },\n            true,\n        );\n\n        Reflect.defineProperty(target.proto, target.propertyKey, originalDescriptor);\n        Reflect.defineMetadata(\n            'aspectjs.originalMethodDescriptor',\n            originalDescriptor,\n            target.proto,\n            target.propertyKey,\n        );\n\n        return super.compile(ctxt, advices);\n    }\n\n    finalize(ctxt: MutableAdviceContext<T, AnnotationType.METHOD>, jp: (args?: any[]) => T): PropertyDescriptor {\n        const newDescriptor = super.finalize(ctxt, jp);\n\n        Reflect.defineProperty(ctxt.target.proto, ctxt.target.propertyKey, newDescriptor);\n\n        // We want any further method advice t use this descriptor as a reference\n        Reflect.defineMetadata(\n            'aspectjs.originalMethodDescriptor',\n            newDescriptor,\n            ctxt.target.proto,\n            ctxt.target.propertyKey,\n        );\n\n        // Override method descriptor from parameter decorator is not allowed because return value of this parameter decorators is ignored\n        // Moreover, Reflect.decorate will overwrite any changes made on proto[propertyKey]\n        // We monkey patch Object.defineProperty to prevent this;\n        Object.defineProperty = function (o: any, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>) {\n            if (o === ctxt.target.proto && p === ctxt.target.propertyKey) {\n                // restore original defineProperty method\n                Object.defineProperty = _defineProperty;\n\n                // if attempt to write an enhanced descriptor... let go\n                if (Reflect.getOwnMetadata('aspectjs.enhancedMethodDescriptor', attributes)) {\n                    return Object.defineProperty(o, p, attributes);\n                } else {\n                    // prevent writing back old descriptor\n                    return newDescriptor;\n                }\n            }\n\n            return _defineProperty(o, p, attributes);\n        };\n\n        return newDescriptor as any;\n    }\n}\n","import {\n    _JoinpointFactory,\n    AdviceError,\n    AdviceTarget,\n    AdviceType,\n    AnnotationType,\n    CompileAdvice,\n    MutableAdviceContext,\n} from '@aspectjs/core/commons';\nimport { assert, getOrComputeMetadata, isFunction, isUndefined, Mutable } from '@aspectjs/core/utils';\nimport { _GenericWeavingStrategy } from './generic-weaving-strategy';\n\n/**\n * @internal\n */\nexport class _PropertyGetWeavingStrategy<T> extends _GenericWeavingStrategy<T, AdviceType.PROPERTY> {\n    private compiledDescriptor: PropertyDescriptor;\n\n    compile(\n        ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>,\n        advices: CompileAdvice<T, AdviceType.PROPERTY>[],\n    ): AdviceType.PROPERTY extends AdviceType.METHOD\n        ? () => T\n        : AdviceType.PROPERTY extends AdviceType.CLASS\n        ? { new (...args: any[]): T }\n        : PropertyDescriptor {\n        const target = ctxt.target;\n        if (this.compiledDescriptor) {\n            return this.compiledDescriptor;\n        }\n\n        // if another @Compile advice has been applied\n        // replace wrapped descriptor by original descriptor before it gets wrapped again\n        (target as Mutable<AdviceTarget>).descriptor = getOrComputeMetadata(\n            'aspectjs.originalDescriptor',\n            target.proto,\n            target.propertyKey,\n            () => {\n                return (\n                    Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey) ?? {\n                        configurable: true,\n                        enumerable: true,\n                        get() {\n                            return Reflect.getOwnMetadata(`aspectjs.propValue`, this, target.propertyKey);\n                        },\n                        set(value: any) {\n                            Reflect.defineMetadata(`aspectjs.propValue`, value, this, target.propertyKey);\n                        },\n                    }\n                );\n            },\n            true,\n        );\n\n        let advice: CompileAdvice<T, AdviceType.PROPERTY>;\n        let newDescriptor: PropertyDescriptor = ctxt.target.descriptor;\n\n        advices.forEach((advice) => {\n            ctxt.advice = advice;\n            newDescriptor = advice(ctxt) ?? newDescriptor;\n        });\n        delete ctxt.advice;\n\n        if (newDescriptor) {\n            if (Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey)?.configurable === false) {\n                throw new AdviceError(advice, `${target.label} is not configurable`);\n            }\n\n            // test property validity\n            const surrogate = { prop: '' };\n            const surrogateProp = Reflect.getOwnPropertyDescriptor(surrogate, 'prop');\n            if (isUndefined(newDescriptor.enumerable)) {\n                newDescriptor.enumerable = surrogateProp.enumerable;\n            }\n\n            if (isUndefined(newDescriptor.configurable)) {\n                newDescriptor.configurable = surrogateProp.configurable;\n            }\n\n            // normalize the descriptor\n            newDescriptor = Object.getOwnPropertyDescriptor(\n                Object.defineProperty(surrogate, 'newProp', newDescriptor),\n                'newProp',\n            );\n\n            Reflect.defineProperty(target.proto, target.propertyKey, newDescriptor);\n        }\n\n        if ((newDescriptor as Record<string, any>).hasOwnProperty('value')) {\n            const propValue = newDescriptor.value;\n            newDescriptor.get = () => propValue;\n            delete newDescriptor.writable;\n            delete newDescriptor.value;\n        }\n\n        return (this.compiledDescriptor = newDescriptor);\n    }\n\n    preBefore(ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>): void {\n        ctxt.args = [];\n    }\n\n    initialJoinpoint(ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>, originalDescriptor: PropertyDescriptor): void {\n        assert(isFunction(originalDescriptor.get));\n        ctxt.value = _JoinpointFactory.create(null, ctxt, originalDescriptor.get)();\n    }\n\n    finalize(\n        ctxt: MutableAdviceContext<T, AnnotationType.PROPERTY>,\n        joinpoint: (...args: any[]) => T,\n    ): AnnotationType.PROPERTY extends AnnotationType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor {\n        const newDescriptor = {\n            ...this.compiledDescriptor,\n            get: joinpoint,\n        };\n\n        // test property validity\n        Object.getOwnPropertyDescriptor(Object.defineProperty({}, 'surrogate', newDescriptor), 'surrogate');\n\n        return newDescriptor;\n    }\n}\n","import {\n    _JoinpointFactory,\n    AdviceType,\n    AfterAdvice,\n    AfterReturnAdvice,\n    AfterThrowAdvice,\n    AnnotationType,\n    AroundAdvice,\n    JoinPoint,\n    MutableAdviceContext,\n} from '@aspectjs/core/commons';\nimport { assert, isFunction } from '@aspectjs/core/utils';\nimport { _GenericWeavingStrategy } from './generic-weaving-strategy';\nimport { _PropertyGetWeavingStrategy } from './property-get-weaving-strategy';\n\n/**\n * @internal\n */\nexport class _PropertySetWeavingStrategy<T> extends _GenericWeavingStrategy<T, AdviceType.PROPERTY> {\n    private compiledDescriptor: PropertyDescriptor;\n\n    constructor(private getterHooks: _PropertyGetWeavingStrategy<T>) {\n        super();\n    }\n\n    compile(\n        ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>,\n    ): AdviceType.PROPERTY extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor {\n        return (this.compiledDescriptor = this.getterHooks.compile(ctxt, null));\n    }\n\n    initialJoinpoint(ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>, refDescriptor: PropertyDescriptor): void {\n        assert(isFunction(refDescriptor?.set));\n        ctxt.value = _JoinpointFactory.create(null, ctxt, refDescriptor.set)(ctxt.args);\n    }\n\n    around(\n        ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>,\n        advices: AroundAdvice<T, AdviceType.PROPERTY>[],\n        jp: JoinPoint<T>,\n    ): JoinPoint<T> {\n        return super.around(ctxt, advices, jp, false);\n    }\n\n    afterReturn(\n        ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>,\n        advices: AfterReturnAdvice<T, AdviceType.PROPERTY>[],\n    ): any {\n        return this._applyNonReturningAdvices(ctxt, advices);\n    }\n\n    afterThrow(\n        ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>,\n        advices: AfterThrowAdvice<T, AdviceType.PROPERTY>[],\n    ): any {\n        super.afterThrow(ctxt, advices, false);\n    }\n\n    after(ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>, advices: AfterAdvice<T, AdviceType.PROPERTY>[]): void {\n        this._applyNonReturningAdvices(ctxt, advices);\n    }\n\n    finalize(\n        ctxt: MutableAdviceContext<T, AnnotationType.PROPERTY>,\n        joinpoint: (...args: any[]) => T,\n    ): AnnotationType.PROPERTY extends AnnotationType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor {\n        const newDescriptor = {\n            ...this.compiledDescriptor,\n            set: joinpoint,\n        };\n\n        // test property validity\n        Object.getOwnPropertyDescriptor(Object.defineProperty({}, 'surrogate', newDescriptor), 'surrogate');\n\n        return newDescriptor;\n    }\n}\n","import {\n    Advice,\n    AdviceTarget,\n    AdviceType,\n    AnnotationsBundle,\n    AnnotationTarget,\n    AnnotationType,\n    AspectType,\n    JoinPoint,\n    MutableAdviceContext,\n    Pointcut,\n    Weaver,\n    WeaverContext,\n    WeaverProfile,\n    WeavingError,\n} from '@aspectjs/core/commons';\nimport { isFunction } from '@aspectjs/core/utils';\nimport { _AdviceExecutionPlanFactory } from '../plan.factory';\nimport { _ClassWeavingStrategy } from './strategies/class-weaving-strategy';\nimport { _MethodWeavingStrategy } from './strategies/method-weaving-strategy';\nimport { _ParameterWeavingStrategy } from './strategies/parameter-weaving-strategy';\nimport { _PropertyGetWeavingStrategy } from './strategies/property-get-weaving-strategy';\nimport { _PropertySetWeavingStrategy } from './strategies/property-set-weaving-strategy';\n\n/**\n * The JitWeaver wires up advices to the corresponding annotations as soon as the annotation gets processed by JS interpreter.\n * @public\n */\nexport class JitWeaver extends WeaverProfile implements Weaver {\n    private _planFactory: _AdviceExecutionPlanFactory;\n    private _enhancers = {\n        [AnnotationType.CLASS]: this._enhanceClass.bind(this),\n        [AnnotationType.PROPERTY]: this._enhanceProperty.bind(this),\n        [AnnotationType.METHOD]: this._enhanceMethod.bind(this),\n        [AnnotationType.PARAMETER]: this._enhanceParameter.bind(this),\n    };\n    /**\n     *\n     * @param _context - the weaver context to attach this weaver to.\n     * @param _prod - When prod mode is activated, enabling an aspect after Annotation compilation is prohibed.\n     */\n    constructor(private _context: WeaverContext, private _prod = true) {\n        super();\n        this._planFactory = new _AdviceExecutionPlanFactory();\n    }\n\n    enable(...aspects: (AspectType | WeaverProfile)[]): this {\n        const _aspects = new WeaverProfile().enable(...aspects).getAspects();\n        try {\n            this._context.aspects.registry.register(..._aspects);\n            if (this._prod) {\n                // check annotations has not already been processed\n                const alreadyProcessedAnnotations = new Map<Pointcut, AspectType>();\n                _aspects.forEach((aspect) => {\n                    this._context.aspects.registry\n                        .getAdvicesByAspect(aspect)\n                        .forEach((a) => alreadyProcessedAnnotations.set(a.pointcut, aspect));\n                });\n\n                alreadyProcessedAnnotations.forEach((aspect: AspectType, pointcut: Pointcut) => {\n                    if (this._context.annotations.bundle.all(pointcut.annotation.ref).length) {\n                        throw new WeavingError(\n                            `Cannot enable aspect ${aspect.constructor?.name ?? aspect} because annotation ${\n                                pointcut.annotation\n                            } has already been applied`,\n                        );\n                    }\n                });\n            }\n\n            const r = super.enable(..._aspects);\n            _aspects.filter((a) => isFunction(a.onEnable)).forEach((a) => a.onEnable.call(a, this));\n\n            return r;\n        } catch (e) {\n            this._context.aspects.registry.remove(..._aspects);\n            throw e;\n        }\n    }\n\n    disable(...aspects: (AspectType | WeaverProfile)[]): this {\n        const _aspects = new WeaverProfile().enable(...aspects).getAspects();\n        _aspects.filter((a) => isFunction(a.onDisable)).forEach((a) => a.onEnable.call(a, this));\n\n        return super.disable(..._aspects);\n    }\n\n    reset(): this {\n        this._planFactory = new _AdviceExecutionPlanFactory();\n        return super.reset();\n    }\n\n    enhance<T>(target: AnnotationTarget<T>): void | Function | PropertyDescriptor {\n        const ctxt = new AdviceContextImpl(target, this._context.annotations.bundle.at(target.location));\n\n        return this._enhancers[target.type](ctxt);\n    }\n\n    private _enhanceClass<T>(ctxt: MutableAdviceContext<T, AdviceType.CLASS>): new (...args: any[]) => T {\n        const plan = this._planFactory.create(ctxt.target, new _ClassWeavingStrategy());\n        return plan.compile(ctxt).link();\n    }\n\n    private _enhanceProperty<T>(ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>): PropertyDescriptor {\n        const getterHooks = new _PropertyGetWeavingStrategy();\n        const gettersPlan = this._planFactory.create(ctxt.target, getterHooks, {\n            name: 'get',\n            fn: _isPropertyGet,\n        });\n\n        const newDescriptor = gettersPlan.compile(ctxt).link();\n\n        if (_isDescriptorWritable(newDescriptor)) {\n            const settersPlan = this._planFactory.create(ctxt.target, new _PropertySetWeavingStrategy(getterHooks), {\n                name: 'set',\n                fn: _isPropertySet,\n            });\n\n            newDescriptor.set = settersPlan.compile(ctxt).link().set;\n            delete newDescriptor.writable;\n        } else {\n            delete newDescriptor.set;\n        }\n\n        const target = ctxt.target;\n        Reflect.defineProperty(target.proto, target.propertyKey, newDescriptor);\n\n        return newDescriptor;\n    }\n\n    private _enhanceMethod<T>(ctxt: MutableAdviceContext<T, AdviceType.METHOD>): PropertyDescriptor {\n        const plan = this._planFactory.create(ctxt.target, new _MethodWeavingStrategy());\n        return plan.compile(ctxt).link();\n    }\n\n    private _enhanceParameter<T>(ctxt: MutableAdviceContext<T, AdviceType.METHOD>): PropertyDescriptor {\n        const plan = this._planFactory.create(ctxt.target, new _ParameterWeavingStrategy());\n        return plan.compile(ctxt).link();\n    }\n}\n\nfunction _isPropertyGet(a: Advice) {\n    return a.pointcut.ref.startsWith('property#get');\n}\n\nfunction _isPropertySet(a: Advice) {\n    return a.pointcut.ref.startsWith('property#set');\n}\n\nfunction _isDescriptorWritable(propDescriptor: PropertyDescriptor) {\n    const desc = propDescriptor as Record<string, any>;\n    return !desc || (desc.hasOwnProperty('writable') && desc.writable) || isFunction(desc.set);\n}\n\nclass AdviceContextImpl<T, A extends AdviceType> implements MutableAdviceContext<unknown, A> {\n    public advice: Advice<T, A>;\n    public error: Error;\n    public instance: T;\n    public value: T | unknown;\n    public args: any[];\n    public joinpoint: JoinPoint;\n    public target: AdviceTarget<T, A>;\n    public data: Record<string, any>;\n    public annotations: AnnotationsBundle;\n\n    constructor(target: AdviceTarget<any, A>, bundle: AnnotationsBundle<T>) {\n        this.target = target;\n        this.data = {};\n        this.annotations = bundle;\n    }\n\n    clone(): this {\n        return Object.assign(Object.create(Reflect.getPrototypeOf(this)) as MutableAdviceContext<unknown, A>, this);\n    }\n\n    toString(): string {\n        return `${this.advice} on ${this.target.label}`;\n    }\n}\n","import {\n    AnnotationBundleRegistry,\n    AnnotationLocationFactory,\n    AnnotationRegistry,\n    AnnotationTargetFactory,\n    AspectsRegistry,\n    RootAnnotationsBundle,\n    Weaver,\n    WeaverContext,\n} from '@aspectjs/core/commons';\nimport { AspectsRegistryImpl } from '../aspect/aspect.registry.impl';\nimport { JitWeaver } from './jit/jit-weaver';\n\nconst bundleRegistry: AnnotationBundleRegistry = {\n    byTargetClassRef: {},\n    byAnnotation: {},\n};\n\nconst bundle = new RootAnnotationsBundle(bundleRegistry);\nconst annotationRegistry = new AnnotationRegistry(bundleRegistry);\n/**\n * @public\n */\nexport class WeaverContextImpl implements WeaverContext {\n    readonly weaver: Weaver;\n    private readonly _targetFactory = new AnnotationTargetFactory();\n\n    readonly aspects: { registry: AspectsRegistry };\n\n    readonly annotations = {\n        location: new AnnotationLocationFactory(this._targetFactory),\n        registry: annotationRegistry,\n        targetFactory: this._targetFactory,\n        bundle,\n    };\n\n    constructor() {\n        this.aspects = {\n            registry: new AspectsRegistryImpl(this),\n        };\n\n        this.weaver = this._createWeaver();\n    }\n\n    protected _createWeaver(): Weaver {\n        return new JitWeaver(this);\n    }\n    /**\n     * Get the global weaver\n     */\n    getWeaver(): Weaver {\n        return this.weaver;\n    }\n}\n","import {\n    AnnotationLocationFactory,\n    AnnotationRegistry,\n    AnnotationTargetFactory,\n    _getWeaverContext,\n    RootAnnotationsBundle,\n    _setWeaverContext,\n    Weaver,\n    WeaverContext,\n    AspectsRegistry,\n} from '@aspectjs/core/commons';\nimport { WeaverContextImpl } from './weaver/weaver-context.impl';\n\n// TODO remove when https://github.com/microsoft/rushstack/issues/1050 is resolved\nlet _AspectsRegistry: AspectsRegistry;\nAnnotationLocationFactory;\nAnnotationRegistry;\nAnnotationTargetFactory;\nRootAnnotationsBundle;\n/**\n * @public\n */\nexport const WEAVER_CONTEXT = new (class implements WeaverContext {\n    // Allow setWeaverContext to switch implementation of weaver.\n    // This is used for resetWaverContext as a convenience for tests\n    get aspects() {\n        return _getWeaverContext().aspects;\n    }\n    get annotations() {\n        return _getWeaverContext().annotations;\n    }\n\n    getWeaver(): Weaver {\n        return _getWeaverContext().getWeaver();\n    }\n})();\n_setWeaverContext(new WeaverContextImpl());\n"],"names":[],"mappings":"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"}