{"version":3,"file":"commons.js","sources":["../../commons/src/annotation/annotation.types.ts","../../commons/src/weaver/errors/aspect-error.ts","../../commons/src/weaver/errors/weaving-error.ts","../../commons/src/weaver/errors/advice-error.ts","../../commons/src/types/pointcut.ts","../../commons/src/weaver/joinpoint-factory.ts","../../commons/src/weaver/profile.ts","../../commons/src/weaver/weaver-context.ts","../../commons/src/advices/advice.factory.ts","../../commons/src/annotation/context/annotation.context.ts","../../commons/src/annotation/registry/annotation.registry.ts","../../commons/src/annotation/target/annotation-target.factory.ts","../../commons/src/annotation/location/location.factory.ts","../../commons/src/annotation/bundle/bundle.ts","../../commons/src/annotation/factory/annotation.factory.ts","../../commons/src/aspectjs.annotation.factory.ts"],"sourcesContent":["/**\n * @public\n */\nimport { assert } from '@aspectjs/core/utils';\n\n/**\n * @public\n */\nexport enum AnnotationType { // TODO use binary-mask values\n    CLASS = 'AnnotationType.CLASS',\n    PROPERTY = 'AnnotationType.PROPERTY',\n    METHOD = 'AnnotationType.METHOD',\n    PARAMETER = 'AnnotationType.PARAMETER',\n}\n\n/**\n * @public\n */\nexport class AnnotationRef {\n    public readonly ref: string;\n    public readonly name: string;\n    public readonly groupId: string;\n\n    constructor(ref: string);\n    constructor(groupId: string, name: string);\n    constructor(groupIdOrRef: string, name?: string) {\n        if (!name) {\n            this.ref = groupIdOrRef;\n            const ANNOTATION_REF_REGEX = /(?<groupId>\\S+):(?<name>\\S+)/;\n            const macth = ANNOTATION_REF_REGEX.exec(this.ref);\n            this.groupId = macth.groups.groupId;\n            this.name = macth.groups.name;\n        } else {\n            this.ref = `${groupIdOrRef}:${name}`;\n            this.name = name;\n            this.groupId = groupIdOrRef;\n        }\n        if (!this.name) {\n            assert(false);\n            throw new Error('cannot create annotation without name');\n        }\n\n        if (!this.groupId) {\n            throw new Error('cannot create annotation without groupId');\n        }\n\n        Object.defineProperty(this, Symbol.toPrimitive, {\n            enumerable: false,\n            value: () => {\n                return `@${this.name}`;\n            },\n        });\n    }\n\n    toString(): string {\n        return `@${this.groupId}:${this.name}`;\n    }\n}\n\n/**\n * @public\n */\nexport type AnnotationStub<T extends Decorator> = (\n    ...args: any[]\n) => T & {\n    name: string;\n};\n\n/**\n * An Annotation is an EcmaScript decorator with no behavior.\n * It relies on an aspect weaver configured with proper aspects to get things done.\n * @public\n */\nexport type Annotation<T extends AnnotationType = any> = (T extends AnnotationType.CLASS\n    ? ClassAnnotation\n    : T extends AnnotationType.METHOD\n    ? MethodAnnotation\n    : T extends AnnotationType.PARAMETER\n    ? ParameterAnnotation\n    : T extends AnnotationType.PROPERTY\n    ? PropertyAnnotation\n    : never) & // eslint-disable-next-line @typescript-eslint/ban-types\n    Function &\n    AnnotationRef;\n\n/**\n * @public\n */\nexport type Decorator<TFunction extends Function = any, T = any> = (\n    target: TFunction | Object,\n    propertyKey?: string | symbol,\n    descriptor?: TypedPropertyDescriptor<T> | number,\n) => TFunction | void | TypedPropertyDescriptor<T>;\n\n/**\n * @public\n */\nexport type ClassAnnotation = AnnotationStub<ClassDecorator> & AnnotationRef;\n/**\n * @public\n */\nexport type MethodAnnotation = AnnotationStub<MethodDecorator> & AnnotationRef;\n/**\n * @public\n */\nexport type ParameterAnnotation = AnnotationStub<ParameterDecorator> & AnnotationRef;\n/**\n * @public\n */\nexport type PropertyAnnotation = AnnotationStub<PropertyDecorator> & AnnotationRef;\n\n/**\n * @public\n */\nexport type ClassAnnotationStub = AnnotationStub<ClassDecorator>;\n/**\n * @public\n */\nexport type MethodAnnotationStub = AnnotationStub<MethodDecorator>;\n/**\n * @public\n */\nexport type PropertyAnnotationStub = AnnotationStub<PropertyDecorator>;\n/**\n * @public\n */\nexport type ParameterAnnotationStub = AnnotationStub<ParameterDecorator>;\n","import { AdviceContext } from '../../advices';\n\n/**\n * Thrown by aspects in case some error occurred during the aspect execution.\n * @public\n */\nexport class AspectError extends Error {\n    constructor(ctxt: AdviceContext, message?: string) {\n        super(`Error applying advice ${ctxt.advice} on ${ctxt.target.label}: ${message}`);\n    }\n}\n","/**\n * Error thrown during the weaving process meaning the weaver has illegal state.\n * @public\n */\nexport class WeavingError extends Error {}\n","import { Advice } from '../../advices';\nimport { WeavingError } from './weaving-error';\n\n/**\n * Error thrown when an advice has an unexpected behavior (eg: returns a value that is not permitted)\n * @public\n */\nexport class AdviceError extends WeavingError {\n    constructor(advice: Advice, message: string) {\n        super(`${advice}: ${message}`);\n    }\n}\n","import { WeavingError } from '../weaver/errors';\nimport {\n    Annotation,\n    AnnotationRef,\n    AnnotationType,\n    ClassAnnotation,\n    MethodAnnotation,\n    ParameterAnnotation,\n    PropertyAnnotation,\n} from '../annotation/annotation.types';\nimport { AdviceType } from '../advices/types';\nimport { assert } from '@aspectjs/core/utils';\n\n/**\n * @public\n */\nexport class PointcutExpression {\n    private readonly _name = '*'; // TODO\n    private readonly _expr: string;\n\n    static of<T extends AdviceType>(type: T, annotation: AnnotationRef) {\n        return AnnotationPointcutExpressionBuilders[type].withAnnotations(annotation as any);\n    }\n    constructor(private _label: string, private _annotations: AnnotationRef[] = []) {\n        this._expr = _trimSpaces(`${this._label} ${this._annotations.map((a) => `@${a.ref}`).join(',')} ${this._name}`);\n    }\n    toString(): string {\n        return this._expr;\n    }\n}\n\n/**\n * @public\n */\nexport class AnnotationPointcutExpressionBuilder<A extends Annotation> {\n    constructor(private _label: string) {}\n\n    withAnnotations(...annotation: Annotation[]): PointcutExpression {\n        return new PointcutExpression(this._label, annotation);\n    }\n}\n\n/**\n * @public\n */\nexport class PropertyAnnotationPointcutExpressionBuilder {\n    readonly setter = new AnnotationPointcutExpressionBuilder<ParameterAnnotation>('property#set');\n\n    withAnnotations(...annotation: PropertyAnnotation[]): PointcutExpression {\n        return new PointcutExpression('property#get', annotation);\n    }\n}\n\n/**\n * @public\n */\nexport interface PointcutExpressionBuilder {\n    readonly class: AnnotationPointcutExpressionBuilder<ClassAnnotation>;\n    readonly property: PropertyAnnotationPointcutExpressionBuilder;\n    readonly method: AnnotationPointcutExpressionBuilder<MethodAnnotation>;\n    readonly parameter: AnnotationPointcutExpressionBuilder<ParameterAnnotation>;\n}\n\nconst AnnotationPointcutExpressionBuilders = {\n    [AnnotationType.CLASS]: new AnnotationPointcutExpressionBuilder<ClassAnnotation>('class'),\n    [AnnotationType.METHOD]: new AnnotationPointcutExpressionBuilder<MethodAnnotation>('method'),\n    [AnnotationType.PARAMETER]: new AnnotationPointcutExpressionBuilder<MethodAnnotation>('parameter'),\n    [AnnotationType.PROPERTY]: new PropertyAnnotationPointcutExpressionBuilder(),\n};\n/**\n * @public\n */\nexport const on: PointcutExpressionBuilder = {\n    class: AnnotationPointcutExpressionBuilders[AnnotationType.CLASS],\n    method: AnnotationPointcutExpressionBuilders[AnnotationType.METHOD],\n    parameter: AnnotationPointcutExpressionBuilders[AnnotationType.PARAMETER],\n    property: AnnotationPointcutExpressionBuilders[AnnotationType.PROPERTY],\n};\n\n/**\n * @public\n */\nexport enum PointcutPhase {\n    COMPILE = 'Compile',\n    AROUND = 'Around',\n    BEFORE = 'Before',\n    AFTERRETURN = 'AfterReturn',\n    AFTER = 'After',\n    AFTERTHROW = 'AfterThrow',\n}\n\n/**\n * @public\n */\nexport interface Pointcut<A extends AdviceType = any> {\n    readonly type: A;\n    readonly annotation: AnnotationRef;\n    readonly name: string;\n    readonly phase: PointcutPhase;\n    readonly ref: string;\n}\n\n/**\n * @public\n */\nexport namespace Pointcut {\n    const POINTCUT_REGEXPS = {\n        [AdviceType.CLASS]: new RegExp('class(?:\\\\s+\\\\@(?<annotation>\\\\S+?:\\\\S+))?(?:\\\\s+(?<name>\\\\S+?))\\\\s*'),\n        [AdviceType.PROPERTY]: new RegExp(\n            'property#(?:get|set)(?:\\\\s+\\\\@(?<annotation>\\\\S+?:\\\\S+))?(?:\\\\s+(?<name>\\\\S+?))\\\\s*',\n        ),\n        [AdviceType.METHOD]: new RegExp('method(?:\\\\s+\\\\@(?<annotation>\\\\S+?:\\\\S+))?(?:\\\\s+(?<name>\\\\S+?))\\\\s*'),\n        [AdviceType.PARAMETER]: new RegExp('parameter(?:\\\\s+\\\\@(?<annotation>\\\\S+?:\\\\S+))?(?:\\\\s+(?<name>\\\\S+?))\\\\s*'),\n    };\n\n    export function of(phase: PointcutPhase, exp: PointcutExpression | string): Pointcut {\n        const ref = exp.toString();\n\n        let pointcut: Pointcut;\n\n        for (const entry of Object.entries(POINTCUT_REGEXPS)) {\n            const [type, regex] = entry;\n            const match = regex.exec(ref);\n\n            if (match?.groups.name) {\n                assert(!!match.groups.annotation, 'only annotation pointcuts are supported');\n                pointcut = {\n                    type: type as AdviceType,\n                    phase,\n                    annotation: new AnnotationRef(match.groups.annotation),\n                    name: match.groups.name,\n                    ref,\n                };\n\n                Reflect.defineProperty(pointcut, Symbol.toPrimitive, {\n                    value: () => `${phase}(${ref})`,\n                });\n\n                return pointcut;\n            }\n        }\n\n        throw new WeavingError(`expression ${ref} not recognized as valid pointcut expression`);\n    }\n}\n\n/**\n * @public\n */\nexport interface CompilePointcut<A extends AdviceType = any> extends Pointcut<A> {\n    phase: PointcutPhase.COMPILE;\n}\n/**\n * @public\n */\nexport interface AroundPointcut<A extends AdviceType = any> extends Pointcut<A> {\n    phase: PointcutPhase.AROUND;\n}\n/**\n * @public\n */\nexport interface BeforePointcut<A extends AdviceType = any> extends Pointcut<A> {\n    phase: PointcutPhase.BEFORE;\n}\n/**\n * @public\n */\nexport interface AfterReturnPointcut<A extends AdviceType = any> extends Pointcut<A> {\n    phase: PointcutPhase.AFTERRETURN;\n}\n/**\n * @public\n */\nexport interface AfterPointcut<A extends AdviceType = any> extends Pointcut<A> {\n    phase: PointcutPhase.AFTER;\n}\n/**\n * @public\n */\nexport interface AfterThrowPointcut<A extends AdviceType = any> extends Pointcut<A> {\n    phase: PointcutPhase.AFTERTHROW;\n}\n\nfunction _trimSpaces(s: string) {\n    return s.replace(/\\s+/, ' ');\n}\n","import { isArray, Mutable } from '@aspectjs/core/utils';\n\nimport { AroundAdvice, AroundContext } from '../advices';\nimport { JoinPoint } from '../types';\nimport { AdviceError } from './errors';\n\n/**\n * @internal\n */\nexport class _JoinpointFactory {\n    static create<T>(\n        advice: AroundAdvice<T>,\n        ctxt: Mutable<AroundContext<T>>,\n        fn: (...args: any[]) => any,\n    ): JoinPoint<T> {\n        function alreadyCalledFn(): void {\n            throw new AdviceError(advice, `joinPoint already proceeded`);\n        }\n\n        return function (args?: unknown[]) {\n            args = args ?? ctxt.args;\n            if (!isArray(args)) {\n                throw new AdviceError(advice, `Joinpoint arguments expected to be array. Got: ${args}`);\n            }\n            const jp = fn;\n            fn = alreadyCalledFn;\n            return jp.apply(ctxt.instance, args);\n        };\n    }\n}\n","import { getAspectOptions, assert, isObject, isString } from '@aspectjs/core/utils';\nimport { AspectType } from '../aspect';\n\n/**\n * A WeaverProfile is a set of Aspects that can be enabled or disabled.\n * The profile itself is meant to be enabled on a Weaver, making it easy to enable multiples aspects at once.\n * @public\n */\nexport class WeaverProfile {\n    protected _aspectsRegistry: {\n        [aspectId: string]: AspectType;\n    } = {};\n\n    constructor() {}\n    enable(...aspects: (AspectType | WeaverProfile)[]): this {\n        aspects.forEach((p) => {\n            if (p instanceof WeaverProfile) {\n                Object.values(p._aspectsRegistry).forEach((p) => this.enable(p));\n            } else {\n                this.setEnabled(p, true);\n            }\n        });\n        return this;\n    }\n    disable(...aspects: (AspectType | string | WeaverProfile)[]): this {\n        aspects.forEach((p) => {\n            if (p instanceof WeaverProfile) {\n                // disable profile\n                Object.values(p._aspectsRegistry).forEach((p) => this.disable(p));\n            } else if (isObject(p)) {\n                // disable aspect\n                this.setEnabled(p, false);\n            } else {\n                assert(isString(p));\n                // delete aspect by id\n                delete this._aspectsRegistry[p];\n            }\n        });\n        return this;\n    }\n    reset(): this {\n        this._aspectsRegistry = {};\n        return this;\n    }\n    setEnabled(aspect: AspectType, enabled: boolean): this {\n        const id = getAspectOptions(aspect).id;\n        if (enabled) {\n            // avoid enabling an aspect twice\n            const oldAspect = this._aspectsRegistry[id];\n            if (oldAspect && oldAspect !== aspect) {\n                console.warn(\n                    `Aspect ${aspect.constructor.name} overrides aspect \"${\n                        oldAspect?.constructor.name ?? 'unknown'\n                    }\" already registered for name ${id}`,\n                );\n            }\n\n            this._aspectsRegistry[id] = aspect;\n        } else {\n            delete this._aspectsRegistry[id];\n        }\n\n        return this;\n    }\n    getAspect<T extends AspectType>(aspect: string | (new () => T)): T | undefined {\n        if (isString(aspect)) {\n            return this._aspectsRegistry[aspect] as T;\n        } else {\n            return this._aspectsRegistry[getAspectOptions(aspect).id] as T;\n        }\n    }\n\n    getAspects<T extends AspectType>(): AspectType[] {\n        return Object.values(this._aspectsRegistry);\n    }\n\n    [Symbol.iterator](): Iterator<AspectType> {\n        const aspects = this.getAspects();\n        let i = 0;\n        return {\n            next: () => {\n                if (i >= aspects.length) {\n                    return { value: undefined, done: true };\n                }\n                return { value: aspects[i++], done: false };\n            },\n        };\n    }\n}\n","import { Weaver } from './weaver';\nimport { AnnotationRegistry } from '../annotation/registry/annotation.registry';\nimport { AnnotationTargetFactory } from '../annotation/target/annotation-target.factory';\nimport { RootAnnotationsBundle } from '../annotation/bundle/bundle';\nimport { AnnotationLocationFactory } from '../annotation/location/location.factory';\nimport { AspectsRegistry } from '../aspect';\n\n/**\n * @public\n */\nexport interface WeaverContext {\n    readonly aspects: {\n        registry: AspectsRegistry;\n    };\n    readonly annotations: {\n        location: AnnotationLocationFactory;\n        registry: AnnotationRegistry;\n        targetFactory: AnnotationTargetFactory;\n        bundle: RootAnnotationsBundle;\n    };\n\n    /**\n     * Get the global weaver\n     */\n    getWeaver(): Weaver;\n}\n\nlet _weaverContext: WeaverContext;\n\n/**\n * @internal\n */\nexport function _getWeaverContext(): WeaverContext {\n    return _weaverContext;\n}\n\n/**\n * @internal\n */\nexport function _setWeaverContext(weaverContext: WeaverContext) {\n    _weaverContext = weaverContext;\n}\n","import { Advice, AdviceType, CompileAdvice } from './types';\nimport { Pointcut, PointcutPhase } from '../types';\nimport { AdviceError, WeavingError } from '../weaver/errors';\nimport { assert, getProto, isFunction } from '@aspectjs/core/utils';\nimport { _getWeaverContext } from '../weaver';\nimport { AdviceTarget } from '../annotation/target/annotation-target';\n\n/**\n * @internal\n */\nexport class _AdviceFactory {\n    static create(pointcut: Pointcut, target: AdviceTarget): Advice {\n        assert(\n            !(pointcut.type === AdviceType.PROPERTY) ||\n                pointcut.ref.startsWith('property#get') ||\n                pointcut.ref.startsWith('property#set'),\n        );\n        const [aspect, propertyKey] = [target.proto, target.propertyKey];\n\n        assert(isFunction(aspect[propertyKey]));\n        let advice: Advice;\n        if (pointcut.phase === PointcutPhase.COMPILE) {\n            // prevent @Compile advices to be called twice\n            advice = function (...args: any[]) {\n                const a = advice as CompileAdvice;\n                advice = (() => {\n                    throw new WeavingError(`${a} already applied`);\n                }) as any;\n\n                return aspect[propertyKey].apply(this, args);\n            } as Advice;\n        } else {\n            advice = function (...args: any[]) {\n                return aspect[propertyKey].apply(this, args);\n            } as Advice;\n        }\n\n        advice.pointcut = pointcut;\n        advice.aspect = aspect;\n\n        Reflect.defineProperty(advice, Symbol.toPrimitive, {\n            value: () =>\n                `@${pointcut.phase}(${pointcut.annotation}) ${aspect.constructor.name}.${String(propertyKey)}()`,\n        });\n\n        Reflect.defineProperty(advice, 'name', {\n            value: propertyKey,\n        });\n\n        if (pointcut.phase === PointcutPhase.COMPILE) {\n            if (pointcut.ref.startsWith('property#set')) {\n                // @Compile(on.property.setter) are forbidden\n                // because PropertyDescriptor can only be setup for both setter & getter at once.\n                throw new AdviceError(advice, `Advice cannot be applied on property setter`);\n            }\n        }\n\n        // assert the weaver is loaded before invoking the underlying decorator\n        const weaverContext = _getWeaverContext();\n        if (!weaverContext) {\n            throw new Error(\n                `Cannot create aspect ${\n                    getProto(aspect).constructor.name ?? ''\n                } before \"setWeaverContext()\" has been called`,\n            );\n        }\n\n        return advice;\n    }\n}\n","import { AdviceTarget } from '../target/annotation-target';\nimport { AnnotationRef, AnnotationType } from '../annotation.types';\n\n/**\n * @public\n */\nexport abstract class AnnotationContext<T = unknown, A extends AnnotationType = any> extends AnnotationRef {\n    readonly args: any[];\n    readonly target: AdviceTarget<T, A>;\n}\n","import { locator } from '@aspectjs/core/utils';\nimport { AnnotationType } from '../annotation.types';\nimport { AnnotationBundleRegistry } from '../bundle/bundle';\nimport { AnnotationContext } from '../context/annotation.context';\n\n/**\n * @public\n */\nexport class AnnotationRegistry {\n    constructor(private readonly _bundleRegistry: AnnotationBundleRegistry) {}\n\n    /**\n     * Registers a new annotation by its AnnotationContext,\n     * so that it can be picked up wy an annotation weaver, or used through AnnotationBundle\n     * @param context - the annotation context to register\n     */\n    register<A extends AnnotationType, T = unknown>(context: AnnotationContext<T, A>) {\n        const byTargetReg = locator(this._bundleRegistry.byTargetClassRef)\n            .at(context.target.declaringClass.ref)\n            .orElseCompute(() => ({\n                byAnnotation: {},\n                all: [],\n            }));\n\n        [byTargetReg, this._bundleRegistry].forEach((reg) => {\n            locator(reg.byAnnotation)\n                .at(context.ref)\n                .orElseCompute(() => [])\n                .push(context);\n        });\n\n        byTargetReg.all.push(context);\n    }\n}\n","import {\n    _getReferenceConstructor,\n    assert,\n    getOrComputeMetadata,\n    getProto,\n    isFunction,\n    isNumber,\n    isObject,\n    isUndefined,\n    locator,\n    Mutable,\n} from '@aspectjs/core/utils';\nimport { AdviceType } from '../../advices/types';\nimport { AnnotationType } from '../annotation.types';\nimport { AnnotationLocation, MethodAnnotationLocation } from '../location/annotation-location';\nimport {\n    AdviceTarget,\n    ClassAdviceTarget,\n    MethodAdviceTarget,\n    ParameterAdviceTarget,\n    PropertyAdviceTarget,\n} from './annotation-target';\n\nlet _globalTargetId = 0;\n/**\n * @public\n */\nexport class AnnotationTargetFactory {\n    private readonly _TARGET_GENERATORS = {\n        [AdviceType.CLASS]: _createClassAnnotationTarget,\n        [AdviceType.PROPERTY]: _createPropertyAnnotationTarget,\n        [AdviceType.METHOD]: _createMethodAnnotationTarget,\n        [AdviceType.PARAMETER]: _createParameterAnnotationTarget,\n    };\n\n    private readonly _REF_GENERATORS = {\n        [AdviceType.CLASS]: (d: Mutable<Partial<ClassAdviceTarget<any>>>) => {\n            const ref = `c[${_getReferenceConstructor(d.proto).name}]`;\n\n            return `${ref}#${getOrComputeMetadata('aspectjs.targetId', d.proto, () => _globalTargetId++)}`;\n        },\n        [AdviceType.PROPERTY]: (d: Mutable<Partial<PropertyAdviceTarget<any>>>) => {\n            return `${this._REF_GENERATORS[AdviceType.CLASS](d as any)}.p[${d.propertyKey}]`;\n        },\n        [AdviceType.METHOD]: (d: Mutable<Partial<MethodAdviceTarget<any>>>) => {\n            return this._REF_GENERATORS[AdviceType.PROPERTY](d as any);\n        },\n        [AdviceType.PARAMETER]: (d: Mutable<Partial<ParameterAdviceTarget<any>>>) => {\n            return `${this._REF_GENERATORS[AdviceType.METHOD](d as any)}.a[${\n                isNaN(d.parameterIndex) ? '*' : d.parameterIndex\n            }]`;\n        },\n    };\n\n    of<T, A extends AdviceType>(args: any[]): AdviceTarget<T, A> {\n        // ClassAnnotation = <TFunction extends Function>(target: TFunction) => TFunction | void;\n        // PropertyAnnotation = (target: Object, propertyKey: string | symbol) => void;\n        // MethodAnnotation = <A>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<A>) => TypedPropertyDescriptor<A> | void;\n        // ParameterAnnotation = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;\n\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        const target: Function | object = args[0];\n        const propertyKey: string | undefined = isUndefined(args[1]) ? undefined : String(args[1]);\n        const parameterIndex: number | undefined = isNumber(args[2]) ? args[2] : undefined;\n        const proto = getProto(target);\n        const descriptor: PropertyDescriptor | undefined = isObject(args[2]) ? args[2] : undefined;\n        const atarget: MutableAdviceTarget<any, AdviceType> = {\n            proto,\n            propertyKey,\n            parameterIndex,\n            descriptor,\n        };\n\n        return this.create(atarget as any);\n    }\n\n    /**\n     * Creates an AnnotationTarget from the given argument\n     * @param target - the AnnotationTarget stub.\n     * @param type - target type override\n     */\n    create<T, A extends AdviceType>(target: MutableAdviceTarget<T, A>, type?: AdviceType): AdviceTarget<T, A> {\n        // determine advice type\n        if (isUndefined(type) && isUndefined(target.type)) {\n            if (isNumber(((target as any) as ParameterAdviceTarget<T>).parameterIndex)) {\n                type = AdviceType.PARAMETER;\n            } else if (!isUndefined(target.propertyKey)) {\n                if (isObject(target.descriptor) && isFunction(target.descriptor.value)) {\n                    type = AdviceType.METHOD;\n                } else {\n                    type = AdviceType.PROPERTY;\n                }\n            } else {\n                type = AdviceType.CLASS;\n            }\n        } else {\n            type = type ?? target.type;\n        }\n\n        const ref = this._REF_GENERATORS[type](target as any);\n        target.type = type as A;\n        return getOrComputeMetadata(_metaKey(ref), target.proto, () => {\n            const t = (this._TARGET_GENERATORS[type] as any)(this, target as any, this._REF_GENERATORS[type]);\n            Reflect.setPrototypeOf(t, AnnotationTargetImpl.prototype);\n\n            return t;\n        }) as any;\n    }\n}\n\nfunction _metaKey(ref: string): string {\n    return `Decorizer.target:${ref}`;\n}\n\nclass AnnotationTargetImpl {\n    toString() {\n        return ((this as any) as AdviceTarget<any, any>).ref;\n    }\n}\n\n/**\n * @public\n */\nexport type MutableAdviceTarget<T, A extends AdviceType> = Mutable<Partial<AdviceTarget<T, A>>>;\n\nfunction _createClassAnnotationTarget<T, A extends AdviceType.CLASS>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, A>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, A> {\n    target = _createAnnotationTarget(target, AdviceType.CLASS, ['proto'], refGenerator) as Mutable<\n        Partial<AdviceTarget<T, A>>\n    >;\n    target.label = `class \"${target.proto.constructor.name}\"`;\n    target.name = target.proto.constructor.name;\n    target.declaringClass = target as any;\n\n    target.location = target.location ?? _createLocation(target);\n\n    const parentClass = _parentClassTargetProperty(targetFactory, target);\n    Object.defineProperties(target, {\n        parent: parentClass,\n        parentClass,\n    });\n\n    return target as AdviceTarget<T, A>;\n}\n\nfunction _createMethodAnnotationTarget<T, D extends AdviceType.METHOD>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, D>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    target = _createAnnotationTarget(target, AdviceType.METHOD, ['proto', 'propertyKey', 'descriptor'], refGenerator);\n\n    target.label = `method \"${target.proto.constructor.name}.${String(target.propertyKey)}\"`;\n    target.name = target.propertyKey;\n    Object.defineProperties(target, {\n        declaringClass: _declaringClassTargetProperty(targetFactory, target),\n        parent: _declaringClassTargetProperty(targetFactory, target),\n        parentClass: _parentClassTargetProperty(targetFactory, target),\n    });\n\n    if (!target.location) {\n        target.location = locator(_getDeclaringClassLocation(target) as any)\n            .at(target.propertyKey)\n            .orElseCompute(() => _createLocation(target) as MethodAnnotationLocation<T>);\n\n        target.location.args = _createAllParametersAnnotationTarget(targetFactory, target, refGenerator)\n            .location as any;\n    }\n\n    return target as AdviceTarget<T, D>;\n}\n\nfunction _getDeclaringClassLocation<T>(target: AnnotationTargetLike<T, AnnotationType>): AnnotationLocation<T> {\n    // retrieve the declaringClass location (location of the declaringClass target)\n    return locator(target.declaringClass)\n        .at('location')\n        .orElseCompute(() => _createLocation(target.declaringClass)); // if no rootLocation exists, create a new one.\n}\n\nfunction _createPropertyAnnotationTarget<T, D extends AdviceType.PROPERTY>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, D>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    target = _createAnnotationTarget(target, AdviceType.PROPERTY, ['proto', 'propertyKey'], refGenerator);\n\n    target.label = `property \"${target.proto.constructor.name}.${String(target.propertyKey)}\"`;\n    Object.defineProperties(target, {\n        declaringClass: _declaringClassTargetProperty(targetFactory, target),\n        parent: _declaringClassTargetProperty(targetFactory, target),\n        parentClass: _parentClassTargetProperty(targetFactory, target),\n    });\n\n    assert(target.type === AdviceType.PROPERTY);\n    target.location =\n        target.location ??\n        locator(_getDeclaringClassLocation<T>(target) as any)\n            .at(target.propertyKey)\n            .orElseCompute(() => _createLocation(target));\n\n    return target as AdviceTarget<T, D>;\n}\n\nfunction _createAllParametersAnnotationTarget<T, D extends AdviceType.PARAMETER | AdviceType.METHOD>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, D>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    target = _createAnnotationTarget<T, D>(\n        { ...target, parameterIndex: NaN as any },\n        AdviceType.PARAMETER,\n        ['parameterIndex', 'proto', 'propertyKey'],\n        refGenerator,\n    );\n    target.label = `parameter \"${target.proto.constructor.name}.${String(target.propertyKey)}(*)})\"`;\n    Object.defineProperties(target, {\n        declaringClass: _declaringClassTargetProperty(targetFactory, target),\n        parent: _declaringMethodTargetProperty(targetFactory, target),\n        parentClass: _parentClassTargetProperty(targetFactory, target),\n    });\n    target.location = target.location ?? _createLocation(target, []);\n    return target;\n}\nfunction _createParameterAnnotationTarget<T, D extends AdviceType.PARAMETER>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, D>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    target = _createAnnotationTarget<T, D>(\n        target,\n        AdviceType.PARAMETER,\n        ['parameterIndex', 'proto', 'propertyKey'],\n        refGenerator,\n    );\n    target.label = `parameter \"${target.proto.constructor.name}.${String(target.propertyKey)}(#${\n        target.parameterIndex\n    })\"`;\n    Object.defineProperties(target, {\n        declaringClass: _declaringClassTargetProperty(targetFactory, target),\n        parent: _declaringMethodTargetProperty(targetFactory, target),\n        parentClass: _parentClassTargetProperty(targetFactory, target),\n    });\n    if (!target.location) {\n        const methodLocation = locator(_getDeclaringClassLocation(target) as any)\n            .at(target.propertyKey)\n            .orElseCompute(() => {\n                return targetFactory.create(\n                    {\n                        proto: target.proto,\n                        propertyKey: target.propertyKey,\n                        descriptor: Object.getOwnPropertyDescriptor(target.proto, target.propertyKey) as any,\n                    },\n                    AdviceType.METHOD,\n                ).location;\n            });\n\n        target.location = locator(methodLocation.args)\n            .at(((target as any) as ParameterAdviceTarget<T>).parameterIndex)\n            .orElseCompute(() => _createLocation(target));\n    }\n    target.descriptor = Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey) as any;\n\n    return target;\n}\n\nfunction _createAnnotationTarget<T, D extends AdviceType>(\n    target: AnnotationTargetLike<T, D>,\n    type: AdviceType,\n    requiredProperties: (keyof AdviceTarget<T, D>)[],\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    requiredProperties.forEach((n) => assert(!isUndefined(target[n]), `target.${n} is undefined`));\n\n    target = { ...target };\n\n    // delete useleff properties\n    Object.keys(target)\n        .filter((p) => requiredProperties.indexOf(p as any) < 0)\n        .forEach((n: keyof AnnotationTargetLike<T, D>) => delete target[n]);\n\n    target.type = type as any;\n    target.ref = target.ref ?? refGenerator(target);\n\n    return target as AdviceTarget<T, D>;\n}\n\ntype AnnotationTargetLike<T, D extends AdviceType> = Mutable<Partial<AdviceTarget<T, D>>>;\n\nfunction _parentClassTargetProperty(\n    targetFactory: AnnotationTargetFactory,\n    dtarget: Partial<AdviceTarget<any, AdviceType>>,\n): PropertyDescriptor {\n    return {\n        get() {\n            const parentProto = Reflect.getPrototypeOf(dtarget.proto);\n            return parentProto === Object.prototype\n                ? undefined\n                : (targetFactory.of([parentProto]) as ClassAdviceTarget<any>);\n        },\n    } as PropertyDescriptor;\n}\n\nfunction _declaringClassTargetProperty(\n    targetFactory: AnnotationTargetFactory,\n    dtarget: Partial<AdviceTarget<any, AdviceType>>,\n): PropertyDescriptor {\n    return {\n        get() {\n            return targetFactory.create({ ...dtarget }, AdviceType.CLASS);\n        },\n    } as PropertyDescriptor;\n}\n\nfunction _declaringMethodTargetProperty(\n    targetFactory: AnnotationTargetFactory,\n    dtarget: Partial<AdviceTarget<any, AdviceType>>,\n): PropertyDescriptor {\n    return {\n        get() {\n            return targetFactory.of([dtarget.proto, dtarget.propertyKey]) as any;\n        },\n    } as PropertyDescriptor;\n}\n\nfunction _createLocation<T, A extends AnnotationType>(\n    target: Partial<AdviceTarget<T, A>>,\n    locationStub: any = new AdviceLocationImpl(),\n): AnnotationLocation<T, A> {\n    const proto = Object.create(Reflect.getPrototypeOf(locationStub));\n    proto.getTarget = () => {\n        return target;\n    };\n\n    Reflect.setPrototypeOf(locationStub, proto);\n\n    return locationStub as AnnotationLocation<T, A>;\n}\n\nclass AdviceLocationImpl<T, D extends AdviceType> {\n    getTarget(): AdviceTarget<T, AdviceType> {\n        throw new Error('No target registered');\n    }\n}\n","import { AdviceType } from '../../advices/types';\nimport { AnnotationTarget, ClassAdviceTarget } from '../target/annotation-target';\nimport { AnnotationLocation, ClassAnnotationLocation } from './annotation-location';\nimport { AnnotationTargetFactory } from '../target/annotation-target.factory';\nimport { getProto } from '@aspectjs/core/utils';\n\n/**\n * @public\n */\nexport class AnnotationLocationFactory {\n    constructor(private _targetFactory: AnnotationTargetFactory) {}\n\n    of<T>(obj: (new () => T) | T): ClassAnnotationLocation<T> {\n        const proto = getProto(obj);\n        if (proto === Object.prototype) {\n            throw new Error('given object is neither a constructor nor a class instance');\n        }\n\n        const target = this._targetFactory.create({\n            proto,\n            type: AdviceType.CLASS,\n        }).declaringClass as ClassAdviceTarget<T>;\n\n        return target.location;\n    }\n\n    static getTarget<T>(location: AnnotationLocation<T>): AnnotationTarget<T> {\n        if (!location) {\n            return undefined;\n        }\n        return Object.getPrototypeOf(location).getTarget();\n    }\n}\n","import { isString, locator } from '@aspectjs/core/utils';\nimport { Annotation, AnnotationRef, AnnotationType } from '../annotation.types';\nimport { AnnotationContext } from '../context/annotation.context';\nimport {\n    AnnotationLocation,\n    ClassAnnotationLocation,\n    MethodAnnotationLocation,\n    ParametersAnnotationLocation,\n    PropertyAnnotationLocation,\n} from '../location/annotation-location';\nimport { AnnotationLocationFactory } from '../location/location.factory';\nimport { AnnotationTarget } from '../target/annotation-target';\n\n/**\n * @public\n */\nexport type AnnotationBundleRegistry<T = unknown, A extends AnnotationType = any> = {\n    byTargetClassRef: {\n        [classTargetRef: string]: {\n            byAnnotation: {\n                [annotationRef: string]: AnnotationContext[];\n            };\n            all: AnnotationContext[];\n        };\n    };\n    byAnnotation: {\n        [annotationRef: string]: AnnotationContext[];\n    };\n};\n\n/**\n * @public\n */\nexport type AnnotationsBundle<T = unknown> =\n    | ClassAnnotationsBundle<T>\n    | MethodAnnotationsBundle<T>\n    | ParameterAnnotationsBundle<T>\n    | PropertyAnnotationsBundle<T>;\n\n/**\n * @public\n */\nexport interface PropertyAnnotationsBundle<T = unknown> {\n    all(\n        ...annotation: (Annotation<AnnotationType.PROPERTY> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<unknown, AnnotationType.PROPERTY>[];\n\n    onProperty(\n        ...annotation: (Annotation<AnnotationType.PROPERTY> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PROPERTY>[];\n\n    onSelf(\n        ...annotation: (Annotation<AnnotationType.PROPERTY> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PROPERTY>[];\n}\n\n/**\n * @public\n */\nexport interface MethodAnnotationsBundle<T = unknown> {\n    all(\n        ...annotation: (Annotation<AnnotationType.METHOD | AnnotationType.PARAMETER> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.METHOD | AnnotationType.PARAMETER>[];\n    onParameter(\n        ...annotation: (Annotation<AnnotationType.PARAMETER> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PARAMETER>[];\n\n    onMethod(\n        ...annotation: (Annotation<AnnotationType.METHOD> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.METHOD | AnnotationType.PARAMETER>[];\n\n    onSelf(\n        ...annotation: (Annotation<AnnotationType.METHOD> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.METHOD | AnnotationType.PARAMETER>[];\n}\n/**\n * @public\n */\nexport interface ParameterAnnotationsBundle<T = unknown> {\n    all(\n        ...annotation: (Annotation<AnnotationType.PARAMETER> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PARAMETER>[];\n\n    onSelf(\n        ...annotation: (Annotation<AnnotationType.PARAMETER> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PARAMETER>[];\n\n    onParameter(\n        ...annotation: (Annotation<AnnotationType.PARAMETER> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PARAMETER>[];\n}\n\n/**\n * @public\n */\nexport class RootAnnotationsBundle {\n    constructor(protected _registry: AnnotationBundleRegistry) {}\n    at<T>(location: MethodAnnotationLocation<T>, searchParents?: boolean): MethodAnnotationsBundle<T>;\n    at<T>(location: ParametersAnnotationLocation<T>, searchParents?: boolean): ParameterAnnotationsBundle<T>;\n    at<T>(location: PropertyAnnotationLocation<T>, searchParents?: boolean): PropertyAnnotationsBundle<T>;\n    at<T>(location: ClassAnnotationLocation<T>, searchParents?: boolean): ClassAnnotationsBundle<T>;\n    at<T>(location: AnnotationLocation<T>, searchParents?: boolean): AnnotationsBundle<T>;\n    at<T>(location: AnnotationLocation<T>, searchParents = true): AnnotationsBundle<T> {\n        return new ClassAnnotationsBundle<T>(this._registry, location, searchParents);\n    }\n\n    all(...annotations: (Annotation | string | AnnotationRef)[]): readonly AnnotationContext[] {\n        if (annotations && annotations.length === 1) {\n            return locator(this._registry.byAnnotation)\n                .at(getAnnotationRef(annotations[0]))\n                .orElseGet(() => []);\n        }\n\n        let entries = Object.entries(this._registry.byAnnotation);\n        if (annotations && annotations.length) {\n            const annotationsSet = new Set<string>(annotations.map((a) => getAnnotationRef(a)));\n            entries = entries.filter((e) => annotationsSet.has(e[0]));\n        }\n        return entries.map((e) => e[1]).flat();\n    }\n}\n\n/**\n * @public\n */\nexport class ClassAnnotationsBundle<T = unknown> extends RootAnnotationsBundle {\n    private _target: AnnotationTarget;\n    constructor(registry: AnnotationBundleRegistry, location: AnnotationLocation, private searchParents: boolean) {\n        super(registry);\n        this._target = AnnotationLocationFactory.getTarget(location);\n    }\n    all(...annotations: (Annotation | string | AnnotationRef)[]): readonly AnnotationContext<T>[] {\n        return this._allWithFilter(this._target, 'all', annotations) as AnnotationContext<T>[];\n    }\n\n    onClass(\n        ...annotations: (Annotation<AnnotationType.CLASS> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.CLASS>[] {\n        return this._allWithFilter(this._target, AnnotationType.CLASS, annotations) as AnnotationContext<\n            T,\n            AnnotationType.CLASS\n        >[];\n    }\n\n    onSelf(\n        ...annotations: (Annotation<AnnotationType.CLASS> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.CLASS>[] {\n        return this._allWithFilter(this._target, this._target.type, annotations) as AnnotationContext<\n            T,\n            AnnotationType.CLASS\n        >[];\n    }\n\n    onProperty(\n        ...annotations: (Annotation<AnnotationType.PROPERTY> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PROPERTY>[] {\n        return this._allWithFilter(this._target, AnnotationType.PROPERTY, annotations) as AnnotationContext<\n            T,\n            AnnotationType.PROPERTY\n        >[];\n    }\n    onMethod(\n        ...annotations: (Annotation<AnnotationType.METHOD> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.METHOD>[] {\n        return this._allWithFilter(this._target, AnnotationType.METHOD, annotations) as AnnotationContext<\n            T,\n            AnnotationType.METHOD\n        >[];\n    }\n    onParameter(\n        ...annotations: (Annotation<AnnotationType.PARAMETER> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PARAMETER>[] {\n        return this._allWithFilter(this._target, AnnotationType.PARAMETER, annotations) as AnnotationContext<\n            T,\n            AnnotationType.PARAMETER\n        >[];\n    }\n\n    private _allWithFilter(\n        target: AnnotationTarget,\n        filter: keyof Filters[AnnotationType],\n        annotations: (Annotation | string | AnnotationRef)[],\n    ): AnnotationContext<T>[] {\n        if (!target) {\n            return [];\n        }\n\n        const parentContext: AnnotationContext[] =\n            target.parentClass && this.searchParents\n                ? this._allWithFilter(target.parentClass, filter, annotations)\n                : [];\n        const reg = locator(this._registry.byTargetClassRef).at(target.declaringClass.ref).get();\n\n        if (!reg) {\n            return parentContext as AnnotationContext<T>[];\n        }\n\n        const annotationsRef = (annotations ?? []).map(getAnnotationRef);\n        let contexts = reg.all;\n        if (annotationsRef.length) {\n            contexts = annotationsRef\n                .map((annotationRef) =>\n                    locator(reg.byAnnotation)\n                        .at(annotationRef)\n                        .orElseGet(() => []),\n                )\n                .flat();\n        }\n        contexts = contexts.filter((a) => FILTERS[target.type][filter](target, a)) as AnnotationContext<T>[];\n\n        return [...parentContext, ...contexts] as AnnotationContext<T>[];\n    }\n}\n//\n// const b: RootAnnotationsBundle = undefined;\n//\n// const o = { attr: '', method() {} };\n// const l = AnnotationLocation.of(o);\n// b.at(AnnotationLocation.of(o)).all();\n//\n// b.at(AnnotationLocation.of(o).attr).all();\n// b.at(AnnotationLocation.of(o).attr).onProperty();\n// b.at(AnnotationLocation.of(o).attr).onMethod();\n// b.at(AnnotationLocation.of(o).attr).onParameter();\n//\n// b.at(AnnotationLocation.of(o).method).all();\n// b.at(AnnotationLocation.of(o).method).onProperty();\n// b.at(AnnotationLocation.of(o).method).onMethod();\n// b.at(AnnotationLocation.of(o).method).onParameter();\n//\n// b.at(AnnotationLocation.of(o).method.args).all();\n// b.at(AnnotationLocation.of(o).method.args).onProperty();\n// b.at(AnnotationLocation.of(o).method.args).onMethod();\n// b.at(AnnotationLocation.of(o).method.args).onParameter();\n\ntype Filters = {\n    [atLocation in AnnotationType]: {\n        all(target: AnnotationTarget, a: AnnotationContext): boolean;\n        [AnnotationType.CLASS](target: AnnotationTarget, a: AnnotationContext): boolean;\n        [AnnotationType.PROPERTY](target: AnnotationTarget, a: AnnotationContext): boolean;\n        [AnnotationType.METHOD](target: AnnotationTarget, a: AnnotationContext): boolean;\n        [AnnotationType.PARAMETER](target: AnnotationTarget, a: AnnotationContext): boolean;\n    };\n};\nconst falseFilter = () => false;\n\nconst FILTERS: Filters = {\n    [AnnotationType.CLASS]: {\n        all(target: AnnotationTarget, a: AnnotationContext) {\n            // keep all if location is the class\n            return true;\n        },\n        [AnnotationType.CLASS](target: AnnotationTarget, a: AnnotationContext) {\n            // keep only annotations on classes\n            return a.target.type === AnnotationType.CLASS;\n        },\n        [AnnotationType.PROPERTY](target: AnnotationTarget, a: AnnotationContext) {\n            // keep only annotations on properties\n            return a.target.type === AnnotationType.PROPERTY;\n        },\n\n        [AnnotationType.METHOD](target: AnnotationTarget, a: AnnotationContext) {\n            // keep only annotations on properties\n            return a.target.type === AnnotationType.METHOD;\n        },\n\n        [AnnotationType.PARAMETER](target: AnnotationTarget, a: AnnotationContext) {\n            // keep only annotations on properties\n            return a.target.type === AnnotationType.PARAMETER;\n        },\n    },\n    [AnnotationType.PROPERTY]: {\n        all(target: AnnotationTarget, a: AnnotationContext) {\n            // keep if same propertyKey\n            return target.propertyKey === a.target.propertyKey;\n        },\n        [AnnotationType.CLASS]: falseFilter,\n        [AnnotationType.PROPERTY](target: AnnotationTarget, a: AnnotationContext) {\n            return FILTERS[target.type].all(target, a);\n        },\n        [AnnotationType.METHOD]: falseFilter,\n        [AnnotationType.PARAMETER]: falseFilter,\n    },\n    [AnnotationType.METHOD]: {\n        all(target: AnnotationTarget, a: AnnotationContext) {\n            const aTarget = a.target;\n\n            // keep if same propertyKey\n            return (\n                target.propertyKey === aTarget.propertyKey &&\n                (aTarget.type === AnnotationType.PARAMETER || aTarget.type === AnnotationType.METHOD)\n            );\n        },\n        [AnnotationType.CLASS]: falseFilter,\n        [AnnotationType.PROPERTY]: falseFilter,\n        [AnnotationType.METHOD](target: AnnotationTarget, a: AnnotationContext) {\n            return (\n                // keep only annotations on properties\n                a.target.type === AnnotationType.METHOD &&\n                // keep only the required method if location is the method\n                target.propertyKey === a.target.propertyKey\n            );\n        },\n\n        [AnnotationType.PARAMETER](target: AnnotationTarget, a: AnnotationContext) {\n            return (\n                // keep only annotations on properties\n                a.target.type === AnnotationType.PARAMETER &&\n                // keep all parameters on method if location is the method\n                target.propertyKey === a.target.propertyKey\n            );\n        },\n    },\n    [AnnotationType.PARAMETER]: {\n        all(target: AnnotationTarget, a: AnnotationContext) {\n            const aTarget = a.target;\n\n            return (\n                // keep if same propertyKey\n                target.propertyKey === aTarget.propertyKey &&\n                // keep parameters if location is parameters\n                aTarget.type === AnnotationType.PARAMETER &&\n                (isNaN(target.parameterIndex) || target.parameterIndex === aTarget.parameterIndex)\n            );\n        },\n        [AnnotationType.CLASS]: falseFilter,\n        [AnnotationType.PROPERTY]: falseFilter,\n        [AnnotationType.METHOD]: falseFilter,\n        [AnnotationType.PARAMETER](target: AnnotationTarget, a: AnnotationContext) {\n            return FILTERS[target.type].all(target, a);\n        },\n    },\n};\n\nfunction getAnnotationRef(annotation: Annotation | string | AnnotationRef): string {\n    return isString(annotation) ? (annotation as string) : annotation?.ref;\n}\n","import { assert, isFunction } from '@aspectjs/core/utils';\nimport { AdviceType } from '../../advices/types';\nimport { _getWeaverContext } from '../../weaver';\nimport {\n    Annotation,\n    AnnotationRef,\n    AnnotationType,\n    ClassAnnotationStub,\n    Decorator,\n    MethodAnnotationStub,\n    ParameterAnnotationStub,\n    PropertyAnnotationStub,\n} from '../annotation.types';\nimport { AnnotationContext } from '../context/annotation.context';\nimport { AdviceTarget, AnnotationTarget } from '../target/annotation-target';\n\nlet generatedId = 0;\n\n/**\n * Factory to create some {@link Annotation}.\n * @public\n */\nexport class AnnotationFactory {\n    private readonly _groupId: string;\n\n    constructor(groupId: string) {\n        this._groupId = groupId;\n    }\n\n    /**\n     * Create a ClassAnnotation.\n     *\n     * @param name - The annotation name.\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends ClassAnnotationStub>(name: string, annotationStub?: A): A & AnnotationRef;\n\n    /**\n     * Create a MethodAnnotation.\n     *\n     * @param name - The annotation name.\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends MethodAnnotationStub>(name: string, annotationStub?: A): A & AnnotationRef;\n\n    /**\n     * Create a PropertyAnnotationStub.\n     *\n     * @param name - The annotation name.\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends PropertyAnnotationStub>(name: string, annotationStub?: A): A & AnnotationRef;\n\n    /**\n     * Create a ParameterAnnotation.\n     *\n     * @param name - The annotation name.\n     * @param annotationStub - The annotation signature.\n     */\n\n    /**\n     * Create a ParameterAnnotation.\n     *\n     * @param name - The annotation name.\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends ParameterAnnotationStub>(name: string, annotationStub?: A): A & AnnotationRef;\n\n    /**\n     * Create a ClassAnnotation.\n     *\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends ClassAnnotationStub>(annotationStub?: A): A & AnnotationRef;\n\n    /**\n     * Create a MethodAnnotation.\n     *\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends MethodAnnotationStub>(annotationStub?: A): A & AnnotationRef;\n\n    /**\n     * Create a PropertyAnnotation.\n     *\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends PropertyAnnotationStub>(annotationStub?: A): A & AnnotationRef;\n\n    /**\n     * Create a ParameterAnnotation.\n     *\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends ParameterAnnotationStub>(annotationStub?: A): A & AnnotationRef;\n\n    create<A extends Annotation<AdviceType>>(name?: string | A, annotationStub?: A): A & AnnotationRef {\n        const groupId = this._groupId;\n\n        if (isFunction(name)) {\n            annotationStub = name as A;\n            name = annotationStub.name;\n        }\n        if (!annotationStub) {\n            annotationStub = function () {} as any;\n        }\n        if (!name) {\n            name = `anonymousAnnotation#${generatedId++}`;\n        }\n        // create the annotation (ie: decorator provider)\n        const annotation = _createAnnotation(\n            name as string,\n            groupId,\n            annotationStub,\n            function (...annotationArgs: any[]): Decorator {\n                return _createBootstrapDecorator(annotation as any, annotationStub, annotationArgs);\n            },\n        );\n\n        return annotation;\n    }\n}\n\nfunction _createAnnotation<A extends Annotation<AdviceType>, D extends Decorator>(\n    name: string,\n    groupId: string,\n    annotationStub: A,\n    fn: Function & D,\n): A {\n    assert(typeof fn === 'function');\n\n    // ensure annotation has a name.\n    annotationStub = annotationStub ?? (function () {} as A);\n\n    const annotationRef = new AnnotationRef(groupId, name);\n    const annotation = (fn as any) as AnnotationRef & A;\n    Object.defineProperties(annotation, Object.getOwnPropertyDescriptors(annotationStub));\n    Object.defineProperties(annotation, Object.getOwnPropertyDescriptors(annotationRef));\n    assert(Object.getOwnPropertySymbols(annotation).indexOf(Symbol.toPrimitive) >= 0);\n\n    return annotation;\n}\n\nfunction _createBootstrapDecorator<A extends AdviceType, S extends Annotation<AdviceType>>(\n    annotation: Annotation<A>,\n    annotationStub: S,\n    annotationArgs: any[],\n): Decorator {\n    return function (...targetArgs: any[]): Function | PropertyDescriptor | void {\n        // eslint-disable-next-line prefer-spread\n        annotationStub(...annotationArgs)?.apply(null, targetArgs);\n\n        // assert the weaver is loaded before invoking the underlying decorator\n        const weaverContext = _getWeaverContext();\n        if (!weaverContext) {\n            throw new Error(\n                `Cannot invoke annotation ${annotation.name ?? ''} before \"setWeaverContext()\" has been called`,\n            );\n        }\n\n        const target = _getWeaverContext().annotations.targetFactory.of(targetArgs) as AnnotationTarget<any, A>;\n        const annotationContext = new AnnotationContextImpl(target, annotationArgs, annotation);\n        weaverContext.annotations.registry.register(annotationContext);\n\n        const enhanced = weaverContext.getWeaver().enhance(target);\n        if (target.type === AnnotationType.CLASS) {\n            Object.defineProperties(enhanced, Object.getOwnPropertyDescriptors(targetArgs[0]));\n        }\n        return enhanced;\n    };\n}\n\nclass AnnotationContextImpl<T, D extends AdviceType> extends AnnotationContext<T, D> {\n    constructor(public readonly target: AdviceTarget<T, D>, public readonly args: any[], annotation: AnnotationRef) {\n        super(annotation.groupId, annotation.name);\n    }\n}\n","import { AnnotationFactory } from './annotation/factory/annotation.factory';\n\n/**\n * The AnnotationFactory used to create annotations of the Aspectjs framework\n * @public\n */\nexport const ASPECTJS_ANNOTATION_FACTORY = new AnnotationFactory('aspectjs');\n"],"names":["AdviceType"],"mappings":"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"}