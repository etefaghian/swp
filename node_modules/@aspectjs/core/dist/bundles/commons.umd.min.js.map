{"version":3,"file":"commons.umd.min.js","sources":["../../commons/src/annotation/annotation.types.ts","../../commons/src/weaver/errors/aspect-error.ts","../../commons/src/weaver/errors/weaving-error.ts","../../commons/src/weaver/errors/advice-error.ts","../../commons/src/types/pointcut.ts","../../commons/src/weaver/profile.ts","../../commons/src/advices/advice.factory.ts","../../commons/src/annotation/registry/annotation.registry.ts","../../commons/src/annotation/target/annotation-target.factory.ts","../../commons/src/annotation/location/location.factory.ts","../../commons/src/annotation/bundle/bundle.ts","../../commons/src/annotation/factory/annotation.factory.ts"],"sourcesContent":["/**\n * @public\n */\nimport { assert } from '@aspectjs/core/utils';\n\n/**\n * @public\n */\nexport enum AnnotationType { // TODO use binary-mask values\n    CLASS = 'AnnotationType.CLASS',\n    PROPERTY = 'AnnotationType.PROPERTY',\n    METHOD = 'AnnotationType.METHOD',\n    PARAMETER = 'AnnotationType.PARAMETER',\n}\n\n/**\n * @public\n */\nexport class AnnotationRef {\n    public readonly ref: string;\n    public readonly name: string;\n    public readonly groupId: string;\n\n    constructor(ref: string);\n    constructor(groupId: string, name: string);\n    constructor(groupIdOrRef: string, name?: string) {\n        if (!name) {\n            this.ref = groupIdOrRef;\n            const ANNOTATION_REF_REGEX = /(?<groupId>\\S+):(?<name>\\S+)/;\n            const macth = ANNOTATION_REF_REGEX.exec(this.ref);\n            this.groupId = macth.groups.groupId;\n            this.name = macth.groups.name;\n        } else {\n            this.ref = `${groupIdOrRef}:${name}`;\n            this.name = name;\n            this.groupId = groupIdOrRef;\n        }\n        if (!this.name) {\n            assert(false);\n            throw new Error('cannot create annotation without name');\n        }\n\n        if (!this.groupId) {\n            throw new Error('cannot create annotation without groupId');\n        }\n\n        Object.defineProperty(this, Symbol.toPrimitive, {\n            enumerable: false,\n            value: () => {\n                return `@${this.name}`;\n            },\n        });\n    }\n\n    toString(): string {\n        return `@${this.groupId}:${this.name}`;\n    }\n}\n\n/**\n * @public\n */\nexport type AnnotationStub<T extends Decorator> = (\n    ...args: any[]\n) => T & {\n    name: string;\n};\n\n/**\n * An Annotation is an EcmaScript decorator with no behavior.\n * It relies on an aspect weaver configured with proper aspects to get things done.\n * @public\n */\nexport type Annotation<T extends AnnotationType = any> = (T extends AnnotationType.CLASS\n    ? ClassAnnotation\n    : T extends AnnotationType.METHOD\n    ? MethodAnnotation\n    : T extends AnnotationType.PARAMETER\n    ? ParameterAnnotation\n    : T extends AnnotationType.PROPERTY\n    ? PropertyAnnotation\n    : never) & // eslint-disable-next-line @typescript-eslint/ban-types\n    Function &\n    AnnotationRef;\n\n/**\n * @public\n */\nexport type Decorator<TFunction extends Function = any, T = any> = (\n    target: TFunction | Object,\n    propertyKey?: string | symbol,\n    descriptor?: TypedPropertyDescriptor<T> | number,\n) => TFunction | void | TypedPropertyDescriptor<T>;\n\n/**\n * @public\n */\nexport type ClassAnnotation = AnnotationStub<ClassDecorator> & AnnotationRef;\n/**\n * @public\n */\nexport type MethodAnnotation = AnnotationStub<MethodDecorator> & AnnotationRef;\n/**\n * @public\n */\nexport type ParameterAnnotation = AnnotationStub<ParameterDecorator> & AnnotationRef;\n/**\n * @public\n */\nexport type PropertyAnnotation = AnnotationStub<PropertyDecorator> & AnnotationRef;\n\n/**\n * @public\n */\nexport type ClassAnnotationStub = AnnotationStub<ClassDecorator>;\n/**\n * @public\n */\nexport type MethodAnnotationStub = AnnotationStub<MethodDecorator>;\n/**\n * @public\n */\nexport type PropertyAnnotationStub = AnnotationStub<PropertyDecorator>;\n/**\n * @public\n */\nexport type ParameterAnnotationStub = AnnotationStub<ParameterDecorator>;\n","import { AdviceContext } from '../../advices';\n\n/**\n * Thrown by aspects in case some error occurred during the aspect execution.\n * @public\n */\nexport class AspectError extends Error {\n    constructor(ctxt: AdviceContext, message?: string) {\n        super(`Error applying advice ${ctxt.advice} on ${ctxt.target.label}: ${message}`);\n    }\n}\n","/**\n * Error thrown during the weaving process meaning the weaver has illegal state.\n * @public\n */\nexport class WeavingError extends Error {}\n","import { Advice } from '../../advices';\nimport { WeavingError } from './weaving-error';\n\n/**\n * Error thrown when an advice has an unexpected behavior (eg: returns a value that is not permitted)\n * @public\n */\nexport class AdviceError extends WeavingError {\n    constructor(advice: Advice, message: string) {\n        super(`${advice}: ${message}`);\n    }\n}\n","import { WeavingError } from '../weaver/errors';\nimport {\n    Annotation,\n    AnnotationRef,\n    AnnotationType,\n    ClassAnnotation,\n    MethodAnnotation,\n    ParameterAnnotation,\n    PropertyAnnotation,\n} from '../annotation/annotation.types';\nimport { AdviceType } from '../advices/types';\nimport { assert } from '@aspectjs/core/utils';\n\n/**\n * @public\n */\nexport class PointcutExpression {\n    private readonly _name = '*'; // TODO\n    private readonly _expr: string;\n\n    static of<T extends AdviceType>(type: T, annotation: AnnotationRef) {\n        return AnnotationPointcutExpressionBuilders[type].withAnnotations(annotation as any);\n    }\n    constructor(private _label: string, private _annotations: AnnotationRef[] = []) {\n        this._expr = _trimSpaces(`${this._label} ${this._annotations.map((a) => `@${a.ref}`).join(',')} ${this._name}`);\n    }\n    toString(): string {\n        return this._expr;\n    }\n}\n\n/**\n * @public\n */\nexport class AnnotationPointcutExpressionBuilder<A extends Annotation> {\n    constructor(private _label: string) {}\n\n    withAnnotations(...annotation: Annotation[]): PointcutExpression {\n        return new PointcutExpression(this._label, annotation);\n    }\n}\n\n/**\n * @public\n */\nexport class PropertyAnnotationPointcutExpressionBuilder {\n    readonly setter = new AnnotationPointcutExpressionBuilder<ParameterAnnotation>('property#set');\n\n    withAnnotations(...annotation: PropertyAnnotation[]): PointcutExpression {\n        return new PointcutExpression('property#get', annotation);\n    }\n}\n\n/**\n * @public\n */\nexport interface PointcutExpressionBuilder {\n    readonly class: AnnotationPointcutExpressionBuilder<ClassAnnotation>;\n    readonly property: PropertyAnnotationPointcutExpressionBuilder;\n    readonly method: AnnotationPointcutExpressionBuilder<MethodAnnotation>;\n    readonly parameter: AnnotationPointcutExpressionBuilder<ParameterAnnotation>;\n}\n\nconst AnnotationPointcutExpressionBuilders = {\n    [AnnotationType.CLASS]: new AnnotationPointcutExpressionBuilder<ClassAnnotation>('class'),\n    [AnnotationType.METHOD]: new AnnotationPointcutExpressionBuilder<MethodAnnotation>('method'),\n    [AnnotationType.PARAMETER]: new AnnotationPointcutExpressionBuilder<MethodAnnotation>('parameter'),\n    [AnnotationType.PROPERTY]: new PropertyAnnotationPointcutExpressionBuilder(),\n};\n/**\n * @public\n */\nexport const on: PointcutExpressionBuilder = {\n    class: AnnotationPointcutExpressionBuilders[AnnotationType.CLASS],\n    method: AnnotationPointcutExpressionBuilders[AnnotationType.METHOD],\n    parameter: AnnotationPointcutExpressionBuilders[AnnotationType.PARAMETER],\n    property: AnnotationPointcutExpressionBuilders[AnnotationType.PROPERTY],\n};\n\n/**\n * @public\n */\nexport enum PointcutPhase {\n    COMPILE = 'Compile',\n    AROUND = 'Around',\n    BEFORE = 'Before',\n    AFTERRETURN = 'AfterReturn',\n    AFTER = 'After',\n    AFTERTHROW = 'AfterThrow',\n}\n\n/**\n * @public\n */\nexport interface Pointcut<A extends AdviceType = any> {\n    readonly type: A;\n    readonly annotation: AnnotationRef;\n    readonly name: string;\n    readonly phase: PointcutPhase;\n    readonly ref: string;\n}\n\n/**\n * @public\n */\nexport namespace Pointcut {\n    const POINTCUT_REGEXPS = {\n        [AdviceType.CLASS]: new RegExp('class(?:\\\\s+\\\\@(?<annotation>\\\\S+?:\\\\S+))?(?:\\\\s+(?<name>\\\\S+?))\\\\s*'),\n        [AdviceType.PROPERTY]: new RegExp(\n            'property#(?:get|set)(?:\\\\s+\\\\@(?<annotation>\\\\S+?:\\\\S+))?(?:\\\\s+(?<name>\\\\S+?))\\\\s*',\n        ),\n        [AdviceType.METHOD]: new RegExp('method(?:\\\\s+\\\\@(?<annotation>\\\\S+?:\\\\S+))?(?:\\\\s+(?<name>\\\\S+?))\\\\s*'),\n        [AdviceType.PARAMETER]: new RegExp('parameter(?:\\\\s+\\\\@(?<annotation>\\\\S+?:\\\\S+))?(?:\\\\s+(?<name>\\\\S+?))\\\\s*'),\n    };\n\n    export function of(phase: PointcutPhase, exp: PointcutExpression | string): Pointcut {\n        const ref = exp.toString();\n\n        let pointcut: Pointcut;\n\n        for (const entry of Object.entries(POINTCUT_REGEXPS)) {\n            const [type, regex] = entry;\n            const match = regex.exec(ref);\n\n            if (match?.groups.name) {\n                assert(!!match.groups.annotation, 'only annotation pointcuts are supported');\n                pointcut = {\n                    type: type as AdviceType,\n                    phase,\n                    annotation: new AnnotationRef(match.groups.annotation),\n                    name: match.groups.name,\n                    ref,\n                };\n\n                Reflect.defineProperty(pointcut, Symbol.toPrimitive, {\n                    value: () => `${phase}(${ref})`,\n                });\n\n                return pointcut;\n            }\n        }\n\n        throw new WeavingError(`expression ${ref} not recognized as valid pointcut expression`);\n    }\n}\n\n/**\n * @public\n */\nexport interface CompilePointcut<A extends AdviceType = any> extends Pointcut<A> {\n    phase: PointcutPhase.COMPILE;\n}\n/**\n * @public\n */\nexport interface AroundPointcut<A extends AdviceType = any> extends Pointcut<A> {\n    phase: PointcutPhase.AROUND;\n}\n/**\n * @public\n */\nexport interface BeforePointcut<A extends AdviceType = any> extends Pointcut<A> {\n    phase: PointcutPhase.BEFORE;\n}\n/**\n * @public\n */\nexport interface AfterReturnPointcut<A extends AdviceType = any> extends Pointcut<A> {\n    phase: PointcutPhase.AFTERRETURN;\n}\n/**\n * @public\n */\nexport interface AfterPointcut<A extends AdviceType = any> extends Pointcut<A> {\n    phase: PointcutPhase.AFTER;\n}\n/**\n * @public\n */\nexport interface AfterThrowPointcut<A extends AdviceType = any> extends Pointcut<A> {\n    phase: PointcutPhase.AFTERTHROW;\n}\n\nfunction _trimSpaces(s: string) {\n    return s.replace(/\\s+/, ' ');\n}\n","import { getAspectOptions, assert, isObject, isString } from '@aspectjs/core/utils';\nimport { AspectType } from '../aspect';\n\n/**\n * A WeaverProfile is a set of Aspects that can be enabled or disabled.\n * The profile itself is meant to be enabled on a Weaver, making it easy to enable multiples aspects at once.\n * @public\n */\nexport class WeaverProfile {\n    protected _aspectsRegistry: {\n        [aspectId: string]: AspectType;\n    } = {};\n\n    constructor() {}\n    enable(...aspects: (AspectType | WeaverProfile)[]): this {\n        aspects.forEach((p) => {\n            if (p instanceof WeaverProfile) {\n                Object.values(p._aspectsRegistry).forEach((p) => this.enable(p));\n            } else {\n                this.setEnabled(p, true);\n            }\n        });\n        return this;\n    }\n    disable(...aspects: (AspectType | string | WeaverProfile)[]): this {\n        aspects.forEach((p) => {\n            if (p instanceof WeaverProfile) {\n                // disable profile\n                Object.values(p._aspectsRegistry).forEach((p) => this.disable(p));\n            } else if (isObject(p)) {\n                // disable aspect\n                this.setEnabled(p, false);\n            } else {\n                assert(isString(p));\n                // delete aspect by id\n                delete this._aspectsRegistry[p];\n            }\n        });\n        return this;\n    }\n    reset(): this {\n        this._aspectsRegistry = {};\n        return this;\n    }\n    setEnabled(aspect: AspectType, enabled: boolean): this {\n        const id = getAspectOptions(aspect).id;\n        if (enabled) {\n            // avoid enabling an aspect twice\n            const oldAspect = this._aspectsRegistry[id];\n            if (oldAspect && oldAspect !== aspect) {\n                console.warn(\n                    `Aspect ${aspect.constructor.name} overrides aspect \"${\n                        oldAspect?.constructor.name ?? 'unknown'\n                    }\" already registered for name ${id}`,\n                );\n            }\n\n            this._aspectsRegistry[id] = aspect;\n        } else {\n            delete this._aspectsRegistry[id];\n        }\n\n        return this;\n    }\n    getAspect<T extends AspectType>(aspect: string | (new () => T)): T | undefined {\n        if (isString(aspect)) {\n            return this._aspectsRegistry[aspect] as T;\n        } else {\n            return this._aspectsRegistry[getAspectOptions(aspect).id] as T;\n        }\n    }\n\n    getAspects<T extends AspectType>(): AspectType[] {\n        return Object.values(this._aspectsRegistry);\n    }\n\n    [Symbol.iterator](): Iterator<AspectType> {\n        const aspects = this.getAspects();\n        let i = 0;\n        return {\n            next: () => {\n                if (i >= aspects.length) {\n                    return { value: undefined, done: true };\n                }\n                return { value: aspects[i++], done: false };\n            },\n        };\n    }\n}\n","import { Advice, AdviceType, CompileAdvice } from './types';\nimport { Pointcut, PointcutPhase } from '../types';\nimport { AdviceError, WeavingError } from '../weaver/errors';\nimport { assert, getProto, isFunction } from '@aspectjs/core/utils';\nimport { _getWeaverContext } from '../weaver';\nimport { AdviceTarget } from '../annotation/target/annotation-target';\n\n/**\n * @internal\n */\nexport class _AdviceFactory {\n    static create(pointcut: Pointcut, target: AdviceTarget): Advice {\n        assert(\n            !(pointcut.type === AdviceType.PROPERTY) ||\n                pointcut.ref.startsWith('property#get') ||\n                pointcut.ref.startsWith('property#set'),\n        );\n        const [aspect, propertyKey] = [target.proto, target.propertyKey];\n\n        assert(isFunction(aspect[propertyKey]));\n        let advice: Advice;\n        if (pointcut.phase === PointcutPhase.COMPILE) {\n            // prevent @Compile advices to be called twice\n            advice = function (...args: any[]) {\n                const a = advice as CompileAdvice;\n                advice = (() => {\n                    throw new WeavingError(`${a} already applied`);\n                }) as any;\n\n                return aspect[propertyKey].apply(this, args);\n            } as Advice;\n        } else {\n            advice = function (...args: any[]) {\n                return aspect[propertyKey].apply(this, args);\n            } as Advice;\n        }\n\n        advice.pointcut = pointcut;\n        advice.aspect = aspect;\n\n        Reflect.defineProperty(advice, Symbol.toPrimitive, {\n            value: () =>\n                `@${pointcut.phase}(${pointcut.annotation}) ${aspect.constructor.name}.${String(propertyKey)}()`,\n        });\n\n        Reflect.defineProperty(advice, 'name', {\n            value: propertyKey,\n        });\n\n        if (pointcut.phase === PointcutPhase.COMPILE) {\n            if (pointcut.ref.startsWith('property#set')) {\n                // @Compile(on.property.setter) are forbidden\n                // because PropertyDescriptor can only be setup for both setter & getter at once.\n                throw new AdviceError(advice, `Advice cannot be applied on property setter`);\n            }\n        }\n\n        // assert the weaver is loaded before invoking the underlying decorator\n        const weaverContext = _getWeaverContext();\n        if (!weaverContext) {\n            throw new Error(\n                `Cannot create aspect ${\n                    getProto(aspect).constructor.name ?? ''\n                } before \"setWeaverContext()\" has been called`,\n            );\n        }\n\n        return advice;\n    }\n}\n","import { locator } from '@aspectjs/core/utils';\nimport { AnnotationType } from '../annotation.types';\nimport { AnnotationBundleRegistry } from '../bundle/bundle';\nimport { AnnotationContext } from '../context/annotation.context';\n\n/**\n * @public\n */\nexport class AnnotationRegistry {\n    constructor(private readonly _bundleRegistry: AnnotationBundleRegistry) {}\n\n    /**\n     * Registers a new annotation by its AnnotationContext,\n     * so that it can be picked up wy an annotation weaver, or used through AnnotationBundle\n     * @param context - the annotation context to register\n     */\n    register<A extends AnnotationType, T = unknown>(context: AnnotationContext<T, A>) {\n        const byTargetReg = locator(this._bundleRegistry.byTargetClassRef)\n            .at(context.target.declaringClass.ref)\n            .orElseCompute(() => ({\n                byAnnotation: {},\n                all: [],\n            }));\n\n        [byTargetReg, this._bundleRegistry].forEach((reg) => {\n            locator(reg.byAnnotation)\n                .at(context.ref)\n                .orElseCompute(() => [])\n                .push(context);\n        });\n\n        byTargetReg.all.push(context);\n    }\n}\n","import {\n    _getReferenceConstructor,\n    assert,\n    getOrComputeMetadata,\n    getProto,\n    isFunction,\n    isNumber,\n    isObject,\n    isUndefined,\n    locator,\n    Mutable,\n} from '@aspectjs/core/utils';\nimport { AdviceType } from '../../advices/types';\nimport { AnnotationType } from '../annotation.types';\nimport { AnnotationLocation, MethodAnnotationLocation } from '../location/annotation-location';\nimport {\n    AdviceTarget,\n    ClassAdviceTarget,\n    MethodAdviceTarget,\n    ParameterAdviceTarget,\n    PropertyAdviceTarget,\n} from './annotation-target';\n\nlet _globalTargetId = 0;\n/**\n * @public\n */\nexport class AnnotationTargetFactory {\n    private readonly _TARGET_GENERATORS = {\n        [AdviceType.CLASS]: _createClassAnnotationTarget,\n        [AdviceType.PROPERTY]: _createPropertyAnnotationTarget,\n        [AdviceType.METHOD]: _createMethodAnnotationTarget,\n        [AdviceType.PARAMETER]: _createParameterAnnotationTarget,\n    };\n\n    private readonly _REF_GENERATORS = {\n        [AdviceType.CLASS]: (d: Mutable<Partial<ClassAdviceTarget<any>>>) => {\n            const ref = `c[${_getReferenceConstructor(d.proto).name}]`;\n\n            return `${ref}#${getOrComputeMetadata('aspectjs.targetId', d.proto, () => _globalTargetId++)}`;\n        },\n        [AdviceType.PROPERTY]: (d: Mutable<Partial<PropertyAdviceTarget<any>>>) => {\n            return `${this._REF_GENERATORS[AdviceType.CLASS](d as any)}.p[${d.propertyKey}]`;\n        },\n        [AdviceType.METHOD]: (d: Mutable<Partial<MethodAdviceTarget<any>>>) => {\n            return this._REF_GENERATORS[AdviceType.PROPERTY](d as any);\n        },\n        [AdviceType.PARAMETER]: (d: Mutable<Partial<ParameterAdviceTarget<any>>>) => {\n            return `${this._REF_GENERATORS[AdviceType.METHOD](d as any)}.a[${\n                isNaN(d.parameterIndex) ? '*' : d.parameterIndex\n            }]`;\n        },\n    };\n\n    of<T, A extends AdviceType>(args: any[]): AdviceTarget<T, A> {\n        // ClassAnnotation = <TFunction extends Function>(target: TFunction) => TFunction | void;\n        // PropertyAnnotation = (target: Object, propertyKey: string | symbol) => void;\n        // MethodAnnotation = <A>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<A>) => TypedPropertyDescriptor<A> | void;\n        // ParameterAnnotation = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;\n\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        const target: Function | object = args[0];\n        const propertyKey: string | undefined = isUndefined(args[1]) ? undefined : String(args[1]);\n        const parameterIndex: number | undefined = isNumber(args[2]) ? args[2] : undefined;\n        const proto = getProto(target);\n        const descriptor: PropertyDescriptor | undefined = isObject(args[2]) ? args[2] : undefined;\n        const atarget: MutableAdviceTarget<any, AdviceType> = {\n            proto,\n            propertyKey,\n            parameterIndex,\n            descriptor,\n        };\n\n        return this.create(atarget as any);\n    }\n\n    /**\n     * Creates an AnnotationTarget from the given argument\n     * @param target - the AnnotationTarget stub.\n     * @param type - target type override\n     */\n    create<T, A extends AdviceType>(target: MutableAdviceTarget<T, A>, type?: AdviceType): AdviceTarget<T, A> {\n        // determine advice type\n        if (isUndefined(type) && isUndefined(target.type)) {\n            if (isNumber(((target as any) as ParameterAdviceTarget<T>).parameterIndex)) {\n                type = AdviceType.PARAMETER;\n            } else if (!isUndefined(target.propertyKey)) {\n                if (isObject(target.descriptor) && isFunction(target.descriptor.value)) {\n                    type = AdviceType.METHOD;\n                } else {\n                    type = AdviceType.PROPERTY;\n                }\n            } else {\n                type = AdviceType.CLASS;\n            }\n        } else {\n            type = type ?? target.type;\n        }\n\n        const ref = this._REF_GENERATORS[type](target as any);\n        target.type = type as A;\n        return getOrComputeMetadata(_metaKey(ref), target.proto, () => {\n            const t = (this._TARGET_GENERATORS[type] as any)(this, target as any, this._REF_GENERATORS[type]);\n            Reflect.setPrototypeOf(t, AnnotationTargetImpl.prototype);\n\n            return t;\n        }) as any;\n    }\n}\n\nfunction _metaKey(ref: string): string {\n    return `Decorizer.target:${ref}`;\n}\n\nclass AnnotationTargetImpl {\n    toString() {\n        return ((this as any) as AdviceTarget<any, any>).ref;\n    }\n}\n\n/**\n * @public\n */\nexport type MutableAdviceTarget<T, A extends AdviceType> = Mutable<Partial<AdviceTarget<T, A>>>;\n\nfunction _createClassAnnotationTarget<T, A extends AdviceType.CLASS>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, A>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, A> {\n    target = _createAnnotationTarget(target, AdviceType.CLASS, ['proto'], refGenerator) as Mutable<\n        Partial<AdviceTarget<T, A>>\n    >;\n    target.label = `class \"${target.proto.constructor.name}\"`;\n    target.name = target.proto.constructor.name;\n    target.declaringClass = target as any;\n\n    target.location = target.location ?? _createLocation(target);\n\n    const parentClass = _parentClassTargetProperty(targetFactory, target);\n    Object.defineProperties(target, {\n        parent: parentClass,\n        parentClass,\n    });\n\n    return target as AdviceTarget<T, A>;\n}\n\nfunction _createMethodAnnotationTarget<T, D extends AdviceType.METHOD>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, D>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    target = _createAnnotationTarget(target, AdviceType.METHOD, ['proto', 'propertyKey', 'descriptor'], refGenerator);\n\n    target.label = `method \"${target.proto.constructor.name}.${String(target.propertyKey)}\"`;\n    target.name = target.propertyKey;\n    Object.defineProperties(target, {\n        declaringClass: _declaringClassTargetProperty(targetFactory, target),\n        parent: _declaringClassTargetProperty(targetFactory, target),\n        parentClass: _parentClassTargetProperty(targetFactory, target),\n    });\n\n    if (!target.location) {\n        target.location = locator(_getDeclaringClassLocation(target) as any)\n            .at(target.propertyKey)\n            .orElseCompute(() => _createLocation(target) as MethodAnnotationLocation<T>);\n\n        target.location.args = _createAllParametersAnnotationTarget(targetFactory, target, refGenerator)\n            .location as any;\n    }\n\n    return target as AdviceTarget<T, D>;\n}\n\nfunction _getDeclaringClassLocation<T>(target: AnnotationTargetLike<T, AnnotationType>): AnnotationLocation<T> {\n    // retrieve the declaringClass location (location of the declaringClass target)\n    return locator(target.declaringClass)\n        .at('location')\n        .orElseCompute(() => _createLocation(target.declaringClass)); // if no rootLocation exists, create a new one.\n}\n\nfunction _createPropertyAnnotationTarget<T, D extends AdviceType.PROPERTY>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, D>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    target = _createAnnotationTarget(target, AdviceType.PROPERTY, ['proto', 'propertyKey'], refGenerator);\n\n    target.label = `property \"${target.proto.constructor.name}.${String(target.propertyKey)}\"`;\n    Object.defineProperties(target, {\n        declaringClass: _declaringClassTargetProperty(targetFactory, target),\n        parent: _declaringClassTargetProperty(targetFactory, target),\n        parentClass: _parentClassTargetProperty(targetFactory, target),\n    });\n\n    assert(target.type === AdviceType.PROPERTY);\n    target.location =\n        target.location ??\n        locator(_getDeclaringClassLocation<T>(target) as any)\n            .at(target.propertyKey)\n            .orElseCompute(() => _createLocation(target));\n\n    return target as AdviceTarget<T, D>;\n}\n\nfunction _createAllParametersAnnotationTarget<T, D extends AdviceType.PARAMETER | AdviceType.METHOD>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, D>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    target = _createAnnotationTarget<T, D>(\n        { ...target, parameterIndex: NaN as any },\n        AdviceType.PARAMETER,\n        ['parameterIndex', 'proto', 'propertyKey'],\n        refGenerator,\n    );\n    target.label = `parameter \"${target.proto.constructor.name}.${String(target.propertyKey)}(*)})\"`;\n    Object.defineProperties(target, {\n        declaringClass: _declaringClassTargetProperty(targetFactory, target),\n        parent: _declaringMethodTargetProperty(targetFactory, target),\n        parentClass: _parentClassTargetProperty(targetFactory, target),\n    });\n    target.location = target.location ?? _createLocation(target, []);\n    return target;\n}\nfunction _createParameterAnnotationTarget<T, D extends AdviceType.PARAMETER>(\n    targetFactory: AnnotationTargetFactory,\n    target: AnnotationTargetLike<T, D>,\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    target = _createAnnotationTarget<T, D>(\n        target,\n        AdviceType.PARAMETER,\n        ['parameterIndex', 'proto', 'propertyKey'],\n        refGenerator,\n    );\n    target.label = `parameter \"${target.proto.constructor.name}.${String(target.propertyKey)}(#${\n        target.parameterIndex\n    })\"`;\n    Object.defineProperties(target, {\n        declaringClass: _declaringClassTargetProperty(targetFactory, target),\n        parent: _declaringMethodTargetProperty(targetFactory, target),\n        parentClass: _parentClassTargetProperty(targetFactory, target),\n    });\n    if (!target.location) {\n        const methodLocation = locator(_getDeclaringClassLocation(target) as any)\n            .at(target.propertyKey)\n            .orElseCompute(() => {\n                return targetFactory.create(\n                    {\n                        proto: target.proto,\n                        propertyKey: target.propertyKey,\n                        descriptor: Object.getOwnPropertyDescriptor(target.proto, target.propertyKey) as any,\n                    },\n                    AdviceType.METHOD,\n                ).location;\n            });\n\n        target.location = locator(methodLocation.args)\n            .at(((target as any) as ParameterAdviceTarget<T>).parameterIndex)\n            .orElseCompute(() => _createLocation(target));\n    }\n    target.descriptor = Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey) as any;\n\n    return target;\n}\n\nfunction _createAnnotationTarget<T, D extends AdviceType>(\n    target: AnnotationTargetLike<T, D>,\n    type: AdviceType,\n    requiredProperties: (keyof AdviceTarget<T, D>)[],\n    refGenerator: (d: Mutable<Partial<AdviceTarget>>) => string,\n): AnnotationTargetLike<T, D> {\n    requiredProperties.forEach((n) => assert(!isUndefined(target[n]), `target.${n} is undefined`));\n\n    target = { ...target };\n\n    // delete useleff properties\n    Object.keys(target)\n        .filter((p) => requiredProperties.indexOf(p as any) < 0)\n        .forEach((n: keyof AnnotationTargetLike<T, D>) => delete target[n]);\n\n    target.type = type as any;\n    target.ref = target.ref ?? refGenerator(target);\n\n    return target as AdviceTarget<T, D>;\n}\n\ntype AnnotationTargetLike<T, D extends AdviceType> = Mutable<Partial<AdviceTarget<T, D>>>;\n\nfunction _parentClassTargetProperty(\n    targetFactory: AnnotationTargetFactory,\n    dtarget: Partial<AdviceTarget<any, AdviceType>>,\n): PropertyDescriptor {\n    return {\n        get() {\n            const parentProto = Reflect.getPrototypeOf(dtarget.proto);\n            return parentProto === Object.prototype\n                ? undefined\n                : (targetFactory.of([parentProto]) as ClassAdviceTarget<any>);\n        },\n    } as PropertyDescriptor;\n}\n\nfunction _declaringClassTargetProperty(\n    targetFactory: AnnotationTargetFactory,\n    dtarget: Partial<AdviceTarget<any, AdviceType>>,\n): PropertyDescriptor {\n    return {\n        get() {\n            return targetFactory.create({ ...dtarget }, AdviceType.CLASS);\n        },\n    } as PropertyDescriptor;\n}\n\nfunction _declaringMethodTargetProperty(\n    targetFactory: AnnotationTargetFactory,\n    dtarget: Partial<AdviceTarget<any, AdviceType>>,\n): PropertyDescriptor {\n    return {\n        get() {\n            return targetFactory.of([dtarget.proto, dtarget.propertyKey]) as any;\n        },\n    } as PropertyDescriptor;\n}\n\nfunction _createLocation<T, A extends AnnotationType>(\n    target: Partial<AdviceTarget<T, A>>,\n    locationStub: any = new AdviceLocationImpl(),\n): AnnotationLocation<T, A> {\n    const proto = Object.create(Reflect.getPrototypeOf(locationStub));\n    proto.getTarget = () => {\n        return target;\n    };\n\n    Reflect.setPrototypeOf(locationStub, proto);\n\n    return locationStub as AnnotationLocation<T, A>;\n}\n\nclass AdviceLocationImpl<T, D extends AdviceType> {\n    getTarget(): AdviceTarget<T, AdviceType> {\n        throw new Error('No target registered');\n    }\n}\n","import { AdviceType } from '../../advices/types';\nimport { AnnotationTarget, ClassAdviceTarget } from '../target/annotation-target';\nimport { AnnotationLocation, ClassAnnotationLocation } from './annotation-location';\nimport { AnnotationTargetFactory } from '../target/annotation-target.factory';\nimport { getProto } from '@aspectjs/core/utils';\n\n/**\n * @public\n */\nexport class AnnotationLocationFactory {\n    constructor(private _targetFactory: AnnotationTargetFactory) {}\n\n    of<T>(obj: (new () => T) | T): ClassAnnotationLocation<T> {\n        const proto = getProto(obj);\n        if (proto === Object.prototype) {\n            throw new Error('given object is neither a constructor nor a class instance');\n        }\n\n        const target = this._targetFactory.create({\n            proto,\n            type: AdviceType.CLASS,\n        }).declaringClass as ClassAdviceTarget<T>;\n\n        return target.location;\n    }\n\n    static getTarget<T>(location: AnnotationLocation<T>): AnnotationTarget<T> {\n        if (!location) {\n            return undefined;\n        }\n        return Object.getPrototypeOf(location).getTarget();\n    }\n}\n","import { isString, locator } from '@aspectjs/core/utils';\nimport { Annotation, AnnotationRef, AnnotationType } from '../annotation.types';\nimport { AnnotationContext } from '../context/annotation.context';\nimport {\n    AnnotationLocation,\n    ClassAnnotationLocation,\n    MethodAnnotationLocation,\n    ParametersAnnotationLocation,\n    PropertyAnnotationLocation,\n} from '../location/annotation-location';\nimport { AnnotationLocationFactory } from '../location/location.factory';\nimport { AnnotationTarget } from '../target/annotation-target';\n\n/**\n * @public\n */\nexport type AnnotationBundleRegistry<T = unknown, A extends AnnotationType = any> = {\n    byTargetClassRef: {\n        [classTargetRef: string]: {\n            byAnnotation: {\n                [annotationRef: string]: AnnotationContext[];\n            };\n            all: AnnotationContext[];\n        };\n    };\n    byAnnotation: {\n        [annotationRef: string]: AnnotationContext[];\n    };\n};\n\n/**\n * @public\n */\nexport type AnnotationsBundle<T = unknown> =\n    | ClassAnnotationsBundle<T>\n    | MethodAnnotationsBundle<T>\n    | ParameterAnnotationsBundle<T>\n    | PropertyAnnotationsBundle<T>;\n\n/**\n * @public\n */\nexport interface PropertyAnnotationsBundle<T = unknown> {\n    all(\n        ...annotation: (Annotation<AnnotationType.PROPERTY> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<unknown, AnnotationType.PROPERTY>[];\n\n    onProperty(\n        ...annotation: (Annotation<AnnotationType.PROPERTY> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PROPERTY>[];\n\n    onSelf(\n        ...annotation: (Annotation<AnnotationType.PROPERTY> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PROPERTY>[];\n}\n\n/**\n * @public\n */\nexport interface MethodAnnotationsBundle<T = unknown> {\n    all(\n        ...annotation: (Annotation<AnnotationType.METHOD | AnnotationType.PARAMETER> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.METHOD | AnnotationType.PARAMETER>[];\n    onParameter(\n        ...annotation: (Annotation<AnnotationType.PARAMETER> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PARAMETER>[];\n\n    onMethod(\n        ...annotation: (Annotation<AnnotationType.METHOD> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.METHOD | AnnotationType.PARAMETER>[];\n\n    onSelf(\n        ...annotation: (Annotation<AnnotationType.METHOD> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.METHOD | AnnotationType.PARAMETER>[];\n}\n/**\n * @public\n */\nexport interface ParameterAnnotationsBundle<T = unknown> {\n    all(\n        ...annotation: (Annotation<AnnotationType.PARAMETER> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PARAMETER>[];\n\n    onSelf(\n        ...annotation: (Annotation<AnnotationType.PARAMETER> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PARAMETER>[];\n\n    onParameter(\n        ...annotation: (Annotation<AnnotationType.PARAMETER> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PARAMETER>[];\n}\n\n/**\n * @public\n */\nexport class RootAnnotationsBundle {\n    constructor(protected _registry: AnnotationBundleRegistry) {}\n    at<T>(location: MethodAnnotationLocation<T>, searchParents?: boolean): MethodAnnotationsBundle<T>;\n    at<T>(location: ParametersAnnotationLocation<T>, searchParents?: boolean): ParameterAnnotationsBundle<T>;\n    at<T>(location: PropertyAnnotationLocation<T>, searchParents?: boolean): PropertyAnnotationsBundle<T>;\n    at<T>(location: ClassAnnotationLocation<T>, searchParents?: boolean): ClassAnnotationsBundle<T>;\n    at<T>(location: AnnotationLocation<T>, searchParents?: boolean): AnnotationsBundle<T>;\n    at<T>(location: AnnotationLocation<T>, searchParents = true): AnnotationsBundle<T> {\n        return new ClassAnnotationsBundle<T>(this._registry, location, searchParents);\n    }\n\n    all(...annotations: (Annotation | string | AnnotationRef)[]): readonly AnnotationContext[] {\n        if (annotations && annotations.length === 1) {\n            return locator(this._registry.byAnnotation)\n                .at(getAnnotationRef(annotations[0]))\n                .orElseGet(() => []);\n        }\n\n        let entries = Object.entries(this._registry.byAnnotation);\n        if (annotations && annotations.length) {\n            const annotationsSet = new Set<string>(annotations.map((a) => getAnnotationRef(a)));\n            entries = entries.filter((e) => annotationsSet.has(e[0]));\n        }\n        return entries.map((e) => e[1]).flat();\n    }\n}\n\n/**\n * @public\n */\nexport class ClassAnnotationsBundle<T = unknown> extends RootAnnotationsBundle {\n    private _target: AnnotationTarget;\n    constructor(registry: AnnotationBundleRegistry, location: AnnotationLocation, private searchParents: boolean) {\n        super(registry);\n        this._target = AnnotationLocationFactory.getTarget(location);\n    }\n    all(...annotations: (Annotation | string | AnnotationRef)[]): readonly AnnotationContext<T>[] {\n        return this._allWithFilter(this._target, 'all', annotations) as AnnotationContext<T>[];\n    }\n\n    onClass(\n        ...annotations: (Annotation<AnnotationType.CLASS> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.CLASS>[] {\n        return this._allWithFilter(this._target, AnnotationType.CLASS, annotations) as AnnotationContext<\n            T,\n            AnnotationType.CLASS\n        >[];\n    }\n\n    onSelf(\n        ...annotations: (Annotation<AnnotationType.CLASS> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.CLASS>[] {\n        return this._allWithFilter(this._target, this._target.type, annotations) as AnnotationContext<\n            T,\n            AnnotationType.CLASS\n        >[];\n    }\n\n    onProperty(\n        ...annotations: (Annotation<AnnotationType.PROPERTY> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PROPERTY>[] {\n        return this._allWithFilter(this._target, AnnotationType.PROPERTY, annotations) as AnnotationContext<\n            T,\n            AnnotationType.PROPERTY\n        >[];\n    }\n    onMethod(\n        ...annotations: (Annotation<AnnotationType.METHOD> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.METHOD>[] {\n        return this._allWithFilter(this._target, AnnotationType.METHOD, annotations) as AnnotationContext<\n            T,\n            AnnotationType.METHOD\n        >[];\n    }\n    onParameter(\n        ...annotations: (Annotation<AnnotationType.PARAMETER> | string | AnnotationRef)[]\n    ): readonly AnnotationContext<T, AnnotationType.PARAMETER>[] {\n        return this._allWithFilter(this._target, AnnotationType.PARAMETER, annotations) as AnnotationContext<\n            T,\n            AnnotationType.PARAMETER\n        >[];\n    }\n\n    private _allWithFilter(\n        target: AnnotationTarget,\n        filter: keyof Filters[AnnotationType],\n        annotations: (Annotation | string | AnnotationRef)[],\n    ): AnnotationContext<T>[] {\n        if (!target) {\n            return [];\n        }\n\n        const parentContext: AnnotationContext[] =\n            target.parentClass && this.searchParents\n                ? this._allWithFilter(target.parentClass, filter, annotations)\n                : [];\n        const reg = locator(this._registry.byTargetClassRef).at(target.declaringClass.ref).get();\n\n        if (!reg) {\n            return parentContext as AnnotationContext<T>[];\n        }\n\n        const annotationsRef = (annotations ?? []).map(getAnnotationRef);\n        let contexts = reg.all;\n        if (annotationsRef.length) {\n            contexts = annotationsRef\n                .map((annotationRef) =>\n                    locator(reg.byAnnotation)\n                        .at(annotationRef)\n                        .orElseGet(() => []),\n                )\n                .flat();\n        }\n        contexts = contexts.filter((a) => FILTERS[target.type][filter](target, a)) as AnnotationContext<T>[];\n\n        return [...parentContext, ...contexts] as AnnotationContext<T>[];\n    }\n}\n//\n// const b: RootAnnotationsBundle = undefined;\n//\n// const o = { attr: '', method() {} };\n// const l = AnnotationLocation.of(o);\n// b.at(AnnotationLocation.of(o)).all();\n//\n// b.at(AnnotationLocation.of(o).attr).all();\n// b.at(AnnotationLocation.of(o).attr).onProperty();\n// b.at(AnnotationLocation.of(o).attr).onMethod();\n// b.at(AnnotationLocation.of(o).attr).onParameter();\n//\n// b.at(AnnotationLocation.of(o).method).all();\n// b.at(AnnotationLocation.of(o).method).onProperty();\n// b.at(AnnotationLocation.of(o).method).onMethod();\n// b.at(AnnotationLocation.of(o).method).onParameter();\n//\n// b.at(AnnotationLocation.of(o).method.args).all();\n// b.at(AnnotationLocation.of(o).method.args).onProperty();\n// b.at(AnnotationLocation.of(o).method.args).onMethod();\n// b.at(AnnotationLocation.of(o).method.args).onParameter();\n\ntype Filters = {\n    [atLocation in AnnotationType]: {\n        all(target: AnnotationTarget, a: AnnotationContext): boolean;\n        [AnnotationType.CLASS](target: AnnotationTarget, a: AnnotationContext): boolean;\n        [AnnotationType.PROPERTY](target: AnnotationTarget, a: AnnotationContext): boolean;\n        [AnnotationType.METHOD](target: AnnotationTarget, a: AnnotationContext): boolean;\n        [AnnotationType.PARAMETER](target: AnnotationTarget, a: AnnotationContext): boolean;\n    };\n};\nconst falseFilter = () => false;\n\nconst FILTERS: Filters = {\n    [AnnotationType.CLASS]: {\n        all(target: AnnotationTarget, a: AnnotationContext) {\n            // keep all if location is the class\n            return true;\n        },\n        [AnnotationType.CLASS](target: AnnotationTarget, a: AnnotationContext) {\n            // keep only annotations on classes\n            return a.target.type === AnnotationType.CLASS;\n        },\n        [AnnotationType.PROPERTY](target: AnnotationTarget, a: AnnotationContext) {\n            // keep only annotations on properties\n            return a.target.type === AnnotationType.PROPERTY;\n        },\n\n        [AnnotationType.METHOD](target: AnnotationTarget, a: AnnotationContext) {\n            // keep only annotations on properties\n            return a.target.type === AnnotationType.METHOD;\n        },\n\n        [AnnotationType.PARAMETER](target: AnnotationTarget, a: AnnotationContext) {\n            // keep only annotations on properties\n            return a.target.type === AnnotationType.PARAMETER;\n        },\n    },\n    [AnnotationType.PROPERTY]: {\n        all(target: AnnotationTarget, a: AnnotationContext) {\n            // keep if same propertyKey\n            return target.propertyKey === a.target.propertyKey;\n        },\n        [AnnotationType.CLASS]: falseFilter,\n        [AnnotationType.PROPERTY](target: AnnotationTarget, a: AnnotationContext) {\n            return FILTERS[target.type].all(target, a);\n        },\n        [AnnotationType.METHOD]: falseFilter,\n        [AnnotationType.PARAMETER]: falseFilter,\n    },\n    [AnnotationType.METHOD]: {\n        all(target: AnnotationTarget, a: AnnotationContext) {\n            const aTarget = a.target;\n\n            // keep if same propertyKey\n            return (\n                target.propertyKey === aTarget.propertyKey &&\n                (aTarget.type === AnnotationType.PARAMETER || aTarget.type === AnnotationType.METHOD)\n            );\n        },\n        [AnnotationType.CLASS]: falseFilter,\n        [AnnotationType.PROPERTY]: falseFilter,\n        [AnnotationType.METHOD](target: AnnotationTarget, a: AnnotationContext) {\n            return (\n                // keep only annotations on properties\n                a.target.type === AnnotationType.METHOD &&\n                // keep only the required method if location is the method\n                target.propertyKey === a.target.propertyKey\n            );\n        },\n\n        [AnnotationType.PARAMETER](target: AnnotationTarget, a: AnnotationContext) {\n            return (\n                // keep only annotations on properties\n                a.target.type === AnnotationType.PARAMETER &&\n                // keep all parameters on method if location is the method\n                target.propertyKey === a.target.propertyKey\n            );\n        },\n    },\n    [AnnotationType.PARAMETER]: {\n        all(target: AnnotationTarget, a: AnnotationContext) {\n            const aTarget = a.target;\n\n            return (\n                // keep if same propertyKey\n                target.propertyKey === aTarget.propertyKey &&\n                // keep parameters if location is parameters\n                aTarget.type === AnnotationType.PARAMETER &&\n                (isNaN(target.parameterIndex) || target.parameterIndex === aTarget.parameterIndex)\n            );\n        },\n        [AnnotationType.CLASS]: falseFilter,\n        [AnnotationType.PROPERTY]: falseFilter,\n        [AnnotationType.METHOD]: falseFilter,\n        [AnnotationType.PARAMETER](target: AnnotationTarget, a: AnnotationContext) {\n            return FILTERS[target.type].all(target, a);\n        },\n    },\n};\n\nfunction getAnnotationRef(annotation: Annotation | string | AnnotationRef): string {\n    return isString(annotation) ? (annotation as string) : annotation?.ref;\n}\n","import { assert, isFunction } from '@aspectjs/core/utils';\nimport { AdviceType } from '../../advices/types';\nimport { _getWeaverContext } from '../../weaver';\nimport {\n    Annotation,\n    AnnotationRef,\n    AnnotationType,\n    ClassAnnotationStub,\n    Decorator,\n    MethodAnnotationStub,\n    ParameterAnnotationStub,\n    PropertyAnnotationStub,\n} from '../annotation.types';\nimport { AnnotationContext } from '../context/annotation.context';\nimport { AdviceTarget, AnnotationTarget } from '../target/annotation-target';\n\nlet generatedId = 0;\n\n/**\n * Factory to create some {@link Annotation}.\n * @public\n */\nexport class AnnotationFactory {\n    private readonly _groupId: string;\n\n    constructor(groupId: string) {\n        this._groupId = groupId;\n    }\n\n    /**\n     * Create a ClassAnnotation.\n     *\n     * @param name - The annotation name.\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends ClassAnnotationStub>(name: string, annotationStub?: A): A & AnnotationRef;\n\n    /**\n     * Create a MethodAnnotation.\n     *\n     * @param name - The annotation name.\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends MethodAnnotationStub>(name: string, annotationStub?: A): A & AnnotationRef;\n\n    /**\n     * Create a PropertyAnnotationStub.\n     *\n     * @param name - The annotation name.\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends PropertyAnnotationStub>(name: string, annotationStub?: A): A & AnnotationRef;\n\n    /**\n     * Create a ParameterAnnotation.\n     *\n     * @param name - The annotation name.\n     * @param annotationStub - The annotation signature.\n     */\n\n    /**\n     * Create a ParameterAnnotation.\n     *\n     * @param name - The annotation name.\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends ParameterAnnotationStub>(name: string, annotationStub?: A): A & AnnotationRef;\n\n    /**\n     * Create a ClassAnnotation.\n     *\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends ClassAnnotationStub>(annotationStub?: A): A & AnnotationRef;\n\n    /**\n     * Create a MethodAnnotation.\n     *\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends MethodAnnotationStub>(annotationStub?: A): A & AnnotationRef;\n\n    /**\n     * Create a PropertyAnnotation.\n     *\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends PropertyAnnotationStub>(annotationStub?: A): A & AnnotationRef;\n\n    /**\n     * Create a ParameterAnnotation.\n     *\n     * @param annotationStub - The annotation signature.\n     */\n    create<A extends ParameterAnnotationStub>(annotationStub?: A): A & AnnotationRef;\n\n    create<A extends Annotation<AdviceType>>(name?: string | A, annotationStub?: A): A & AnnotationRef {\n        const groupId = this._groupId;\n\n        if (isFunction(name)) {\n            annotationStub = name as A;\n            name = annotationStub.name;\n        }\n        if (!annotationStub) {\n            annotationStub = function () {} as any;\n        }\n        if (!name) {\n            name = `anonymousAnnotation#${generatedId++}`;\n        }\n        // create the annotation (ie: decorator provider)\n        const annotation = _createAnnotation(\n            name as string,\n            groupId,\n            annotationStub,\n            function (...annotationArgs: any[]): Decorator {\n                return _createBootstrapDecorator(annotation as any, annotationStub, annotationArgs);\n            },\n        );\n\n        return annotation;\n    }\n}\n\nfunction _createAnnotation<A extends Annotation<AdviceType>, D extends Decorator>(\n    name: string,\n    groupId: string,\n    annotationStub: A,\n    fn: Function & D,\n): A {\n    assert(typeof fn === 'function');\n\n    // ensure annotation has a name.\n    annotationStub = annotationStub ?? (function () {} as A);\n\n    const annotationRef = new AnnotationRef(groupId, name);\n    const annotation = (fn as any) as AnnotationRef & A;\n    Object.defineProperties(annotation, Object.getOwnPropertyDescriptors(annotationStub));\n    Object.defineProperties(annotation, Object.getOwnPropertyDescriptors(annotationRef));\n    assert(Object.getOwnPropertySymbols(annotation).indexOf(Symbol.toPrimitive) >= 0);\n\n    return annotation;\n}\n\nfunction _createBootstrapDecorator<A extends AdviceType, S extends Annotation<AdviceType>>(\n    annotation: Annotation<A>,\n    annotationStub: S,\n    annotationArgs: any[],\n): Decorator {\n    return function (...targetArgs: any[]): Function | PropertyDescriptor | void {\n        // eslint-disable-next-line prefer-spread\n        annotationStub(...annotationArgs)?.apply(null, targetArgs);\n\n        // assert the weaver is loaded before invoking the underlying decorator\n        const weaverContext = _getWeaverContext();\n        if (!weaverContext) {\n            throw new Error(\n                `Cannot invoke annotation ${annotation.name ?? ''} before \"setWeaverContext()\" has been called`,\n            );\n        }\n\n        const target = _getWeaverContext().annotations.targetFactory.of(targetArgs) as AnnotationTarget<any, A>;\n        const annotationContext = new AnnotationContextImpl(target, annotationArgs, annotation);\n        weaverContext.annotations.registry.register(annotationContext);\n\n        const enhanced = weaverContext.getWeaver().enhance(target);\n        if (target.type === AnnotationType.CLASS) {\n            Object.defineProperties(enhanced, Object.getOwnPropertyDescriptors(targetArgs[0]));\n        }\n        return enhanced;\n    };\n}\n\nclass AnnotationContextImpl<T, D extends AdviceType> extends AnnotationContext<T, D> {\n    constructor(public readonly target: AdviceTarget<T, D>, public readonly args: any[], annotation: AnnotationRef) {\n        super(annotation.groupId, annotation.name);\n    }\n}\n"],"names":["AnnotationType","name","groupId","groupIdOrRef","ref","macth","Error","this","Object","defineProperty","AspectError","WeavingError","AdviceError","_expr","AnnotationPointcutExpressionBuilders","parameter","CLASS","RegExp","p","forEach","assert","id","getAspectOptions","aspect","enabled","oldAspect","_aspectsRegistry","console","warn","PointcutPhase","propertyKey","apply","args","pointcut","Reflect","_advice","value","locator","context","AnnotationTargetFactory","d","PARAMETER","AnnotationTargetImpl","targetFactory","label","target","_a","parentClass","defineProperties","_declaringClassTargetProperty","AdviceType","refGenerator","_parentClassTargetProperty","location","_createLocation","declaringClass","_createPropertyAnnotationTarget","proto","_getDeclaringClassLocation","_registry","byAnnotation","annotations","annotationsSet","entries","filter","registry","_allWithFilter","AnnotationFactory"],"mappings":"q6MAQA,wFACI,MAAA,uBACAA,eAAA,SAAA,0BACAA,eAAA,OAAA,wBACAA,eAAA,UAAA,wOAoBWC,2EAUEC,QAAUC,uBATVC,IAAMD,mXAINF,KAAOI,2DAUFC,mDAGTC,yEAKLC,OAAOC,qPC/CFC,8UCJAC,wOAAqBL,QCKrBM,mhBCyBAC,+kCAgCwF,y4BAuCpFC,8IACbC,4jBA8EgBC,MAAQ,IAAIC,u6DCzKxB,gOAIQC,sIAMDX,sLAGCY,gDAEAX,kGACgBU,4BAGhBE,0MAWFC,GAAKC,uBAAiBC,QAAQF,MAChCG,QAAS,KAEHC,UAAYlB,KAAKmB,iBAAiBL,IACpCI,WAAaA,YAAcF,QAC3BI,QAAQC,4GAOS,wBAAc3B,4WAsBhCO,6GAKC,8dCjESJ,uMAMMyB,gPAQRN,OAAOO,aAAaC,MAAMxB,KAAMyB,iDAIrBA,kDAAAA,2CACJF,gCAOfG,wCAIPC,uBAAuBC,4BACnBC,0NASAH,s5BCvCoBI,oKAQV9B,gFAGF+B,QAAQlC,sICoBnBmC,4sBAUWvB,OAA2B,SAACwB,+DACmCvC,0BAE7DG,mgBASFqC,qRAc2B,wdAwBbA,+lBAkD5BC,wQAgBFC,wGAOA3B,OACA,wBAIO4B,0DACPC,OAAO5C,wFAGQ6C,gEAGTC,oEACNvC,OAAOwC,iBACHH,mGAoBJF,kKAMOC,2OAaKK,8BAA8BN,4KAQ9BE,2PA4ERK,2DAC4B,eAC5BC,wKAQgBF,8BAA8BN,cAAeE,oEAE7DE,YAAaK,mDAGjBP,OAAOQ,qDAA8BC,2BAE9BT,oIA7EeU,0GAO1B,SAASC,8CAMLX,OAEAM,4BAGAN,8IAEqEY,mEAErEjD,OAAOwC,mOAaAH,yHAGKa,uCACAb,uFAyChB,0CACIF,qBAEAQ,ymGC9TmDnC,qvBC2PvB2C,UAA4BC,6JAMjCC,wBACSC,mFACxBC,gBAAkBC,QAAO,mEAId,8PAUPC,yoBAcIC,0qJC/MPC,uHAIWjE"}