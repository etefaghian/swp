{"version":3,"file":"core.umd.js","sources":["../../src/aspect/aspect.registry.impl.ts","../../src/weaver/plan.factory.ts","../../src/weaver/utils.ts","../../src/weaver/jit/strategies/generic-weaving-strategy.ts","../../src/weaver/jit/strategies/class-weaving-strategy.ts","../../src/weaver/jit/strategies/method-weaving-strategy.ts","../../src/weaver/jit/strategies/parameter-weaving-strategy.ts","../../src/weaver/jit/strategies/property-get-weaving-strategy.ts","../../src/weaver/jit/strategies/property-set-weaving-strategy.ts","../../src/weaver/jit/jit-weaver.ts","../../src/weaver/weaver-context.impl.ts","../../src/core.ts"],"sourcesContent":["import { After, AfterReturn, AfterThrow, Around, Before, Compile, Order } from '@aspectjs/core/annotations';\nimport {\n    _AdviceFactory,\n    _getWeaverContext,\n    Advice,\n    AdvicesFilter,\n    AdvicesRegistry,\n    AdviceTarget,\n    AdviceType,\n    AnnotationContext,\n    AnnotationLocationFactory,\n    AspectsRegistry,\n    AspectType,\n    Pointcut,\n    PointcutExpression,\n    PointcutPhase,\n    WeaverContext,\n} from '@aspectjs/core/commons';\nimport { assert, assertIsAspect, locator } from '@aspectjs/core/utils';\n\n/**\n * Stores the aspects along with their advices.\n * @public\n */\nexport class AspectsRegistryImpl implements AspectsRegistry {\n    private readonly _advicesRegistryKey: string;\n    private _advicesRegistry: AdvicesRegistry = {\n        byPointcut: {},\n        byTarget: {},\n        byAspect: {},\n    };\n    private _dirty = true;\n    private readonly _aspectsToLoad: Set<AspectType> = new Set<AspectType>();\n    private readonly _loadedAspects: Set<AspectType> = new Set<AspectType>();\n\n    constructor(private _weaverContext: WeaverContext) {\n        this._advicesRegistryKey = `aspectjs.adviceRegistry.byAspects`; // TODO increment key with AspectsRegistry instance ?\n    }\n\n    /**\n     * Register a new advice, with the aspect it belongs to.\n     * @param aspects - The aspects to register\n     */\n    register(...aspects: AspectType[]): void {\n        (aspects ?? []).forEach((aspect) => {\n            // get annotations bundle\n            const annotationsContext = _getWeaverContext().annotations;\n            const bundle = annotationsContext.bundle.at(annotationsContext.location.of(aspect));\n\n            // get @Aspect options\n            const target = this._getTarget(aspect);\n\n            const byAspectRegistry = locator(this._advicesRegistry.byAspect)\n                .at(target.ref)\n                .orElseCompute(() => ({}));\n\n            this._aspectsToLoad.add(aspect);\n            [\n                [Compile, PointcutPhase.COMPILE],\n                [Before, PointcutPhase.BEFORE],\n                [Around, PointcutPhase.AROUND],\n                [After, PointcutPhase.AFTER],\n                [AfterReturn, PointcutPhase.AFTERRETURN],\n                [AfterThrow, PointcutPhase.AFTERTHROW],\n            ].forEach((adviceDef) => {\n                bundle.onMethod(adviceDef[0]).forEach((annotation) => {\n                    const expr = annotation.args[0] as PointcutExpression;\n                    assert(!!expr);\n\n                    const advice = _AdviceFactory.create(\n                        Pointcut.of(adviceDef[1] as PointcutPhase, expr),\n                        annotation.target,\n                    );\n                    const k = `${advice.pointcut.ref}=>${advice.name}`;\n                    byAspectRegistry[k] = advice;\n                });\n            });\n        });\n    }\n\n    remove(...aspects: AspectType[]): void {\n        this._dirty = true;\n        if (this._aspectsToLoad.size) {\n            aspects.forEach((a) => {\n                // remove aspect from the list of aspects to load\n                this._aspectsToLoad.delete(a);\n\n                // remove aspect from registry\n                delete this._advicesRegistry.byAspect[this._getTarget(a).ref];\n            });\n        }\n\n        // force all aspects to reload\n        this._loadedAspects.forEach((a) => this._aspectsToLoad.add(a));\n        this._loadedAspects.clear();\n    }\n\n    /**\n     * Get all advices that belongs to the given aspect\n     * @param aspect - the aspect to get advices for.\n     */\n    getAdvicesByAspect(aspect: AspectType): Advice[] {\n        assertIsAspect(aspect);\n        const target = this._getTarget(aspect);\n\n        return Object.values(this._advicesRegistry.byAspect[target.ref] ?? {})\n            .flat()\n            .map((advice) => {\n                const bound = advice.bind(aspect);\n                Object.defineProperties(bound, Object.getOwnPropertyDescriptors(advice));\n                return bound as Advice;\n            });\n    }\n\n    getAdvicesByTarget<T, A extends AdviceType, P extends PointcutPhase>(\n        target: AdviceTarget<T, A>,\n        filter?: AdvicesFilter,\n        ...phases: PointcutPhase[]\n    ): AdvicesRegistry['byTarget'][string] {\n        this._load();\n\n        const targetRegistry = locator(this._advicesRegistry)\n            .at('byTarget')\n            .at(`${target.ref}${filter?.name ? `:${filter?.name}` : ''}`)\n            .orElseGet(() => ({}));\n\n        // get all advices that correspond to all the annotations of this context\n        const bundle = this._weaverContext.annotations.bundle.at(target.location);\n        const annotationContexts: readonly AnnotationContext[] = bundle.onSelf();\n\n        (phases ?? []).forEach((phase) => {\n            if (!targetRegistry[phase]) {\n                let advices = annotationContexts\n                    .map((annotationContext) =>\n                        locator(this._advicesRegistry)\n                            .at('byPointcut')\n                            .at(phase)\n                            .at(target.type)\n                            .at('byAnnotation')\n                            .at(annotationContext.ref)\n                            .orElseGet(() => [] as any),\n                    )\n                    .flat()\n                    .sort((a1: Advice, a2: Advice) => {\n                        // sort by advice order\n                        const a = this._weaverContext.annotations;\n                        const o1 = a.bundle.at(a.location.of(a1.aspect as any)[a1.name]).onMethod(Order)[0]?.args[0];\n                        const o2 = a.bundle.at(a.location.of(a2.aspect as any)[a1.name]).onMethod(Order)[0]?.args[0];\n\n                        return _compareOrder(o1, o2);\n                    });\n\n                if (filter) {\n                    advices = advices.filter(filter.fn);\n                }\n                (targetRegistry as any)[phase] = advices;\n            }\n        });\n        return targetRegistry;\n    }\n    /**\n     * @internal\n     */\n    private _getTarget<T>(obj: T): AdviceTarget<T> {\n        return AnnotationLocationFactory.getTarget(this._weaverContext.annotations.location.of(obj));\n    }\n\n    /**\n     * Sort the aspects according to their precedence & store by target, by phase & type\n     * @private\n     */\n    private _load() {\n        if (this._dirty) {\n            this._advicesRegistry.byPointcut = {};\n            this._advicesRegistry.byTarget = {};\n        }\n        if (!this._aspectsToLoad.size) {\n            return;\n        }\n\n        [...this._aspectsToLoad]\n            .sort((a1: any, a2: any) => {\n                // sort by aspect order\n                const a = this._weaverContext.annotations;\n                const o1 = a.bundle.at(a.location.of(a1)).onClass(Order)[0]?.args[0];\n                const o2 = a.bundle.at(a.location.of(a2)).onClass(Order)[0]?.args[0];\n\n                return _compareOrder(o1, o2);\n            })\n            .map((a) => {\n                this._loadedAspects.add(a);\n                return a;\n            })\n            .map((aspect: AspectType) => this.getAdvicesByAspect(aspect))\n            .flat()\n            .forEach((advice: Advice) => {\n                const pc = advice.pointcut;\n                locator(this._advicesRegistry)\n                    .at('byPointcut')\n                    .at(pc.phase)\n                    .at(pc.type)\n                    .at('byAnnotation')\n                    .at(pc.annotation.ref)\n                    .orElseCompute(() => [])\n                    .push(advice);\n            });\n        this._dirty = false;\n        this._aspectsToLoad.clear();\n    }\n}\n\nfunction _compareOrder(o1: any, o2: any) {\n    if (o1 === Order.LOWEST_PRECEDENCE || o1 === undefined) {\n        return 1;\n    }\n\n    if (o2 === Order.LOWEST_PRECEDENCE || o2 === undefined) {\n        return -1;\n    }\n\n    if (o1 === Order.HIGHEST_PRECEDENCE) {\n        return -1;\n    }\n\n    if (o2 === Order.HIGHEST_PRECEDENCE) {\n        return 1;\n    }\n    return o1 - o2;\n}\n","import {\n    _getWeaverContext,\n    _JoinpointFactory,\n    Advice,\n    AdviceTarget,\n    AdviceType,\n    CompileAdvice,\n    MutableAdviceContext,\n    PointcutPhase,\n    WeaverContext,\n    WeavingError,\n} from '@aspectjs/core/commons';\nimport { assert } from '@aspectjs/core/utils';\nimport { _WeavingStrategy } from './weaving-strategy';\n\n/**\n * @internal\n */\nexport class _AdviceExecutionPlanFactory {\n    create<T, A extends AdviceType = any>(\n        target: AdviceTarget<T, A>,\n        hooks: _WeavingStrategy<T, A>,\n        filter?: {\n            name: string;\n            fn: (a: Advice) => boolean;\n        },\n    ): _ExecutionPlan<T, A> {\n        let compiled = false;\n        let compiledSymbol: A extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor;\n\n        const linkFn = (ctxt: MutableAdviceContext<T, A>) => {\n            if (!compiled) {\n                compileFn(ctxt);\n            }\n            assert(!!compiledSymbol);\n\n            const jp = function (...args: any[]): T {\n                ctxt.args = args;\n                ctxt.instance = this;\n                const advicesReg = _getWeaverContext().aspects.registry.getAdvicesByTarget(\n                    ctxt.target,\n                    filter,\n                    PointcutPhase.BEFORE,\n                    PointcutPhase.AROUND,\n                    PointcutPhase.AFTERRETURN,\n                    PointcutPhase.AFTERTHROW,\n                    PointcutPhase.AFTER,\n                );\n\n                // create the joinpoint for the original method\n                const jp = _JoinpointFactory.create(null, ctxt, (...args: any[]) => {\n                    const restoreJp = ctxt.joinpoint;\n                    const restoreArgs = ctxt.args;\n                    ctxt.args = args;\n                    delete ctxt.joinpoint;\n\n                    try {\n                        hooks.preBefore?.call(hooks, ctxt);\n                        hooks.before(ctxt, advicesReg[PointcutPhase.BEFORE] as Advice<T, A, PointcutPhase.BEFORE>[]);\n\n                        hooks.initialJoinpoint.call(hooks, ctxt, compiledSymbol);\n\n                        hooks.preAfterReturn?.call(hooks, ctxt);\n                        return hooks.afterReturn(\n                            ctxt,\n                            advicesReg[PointcutPhase.AFTERRETURN] as Advice<T, A, PointcutPhase.AFTERRETURN>[],\n                        );\n                    } catch (e) {\n                        // consider WeavingErrors as not recoverable by an aspect\n                        if (e instanceof WeavingError) {\n                            throw e;\n                        }\n                        ctxt.error = e;\n\n                        hooks.preAfterThrow?.call(hooks, ctxt);\n                        return hooks.afterThrow(\n                            ctxt,\n                            advicesReg[PointcutPhase.AFTERTHROW] as Advice<T, A, PointcutPhase.AFTERTHROW>[],\n                        );\n                    } finally {\n                        delete ctxt.error;\n                        hooks.preAfter?.call(hooks, ctxt);\n                        hooks.after(ctxt, advicesReg[PointcutPhase.AFTER] as Advice<T, A, PointcutPhase.AFTER>[]);\n                        ctxt.joinpoint = restoreJp;\n                        ctxt.args = restoreArgs;\n                    }\n                });\n\n                hooks.preAround?.call(hooks, ctxt);\n                return hooks.around(\n                    ctxt,\n                    advicesReg[PointcutPhase.AROUND] as Advice<T, A, PointcutPhase.AROUND>[],\n                    jp,\n                )(args);\n            };\n\n            return hooks.finalize.call(hooks, ctxt, jp) ?? jp;\n        };\n        const compileFn = (ctxt: MutableAdviceContext<T, A>) => {\n            const compileAdvices = _getWeaverContext().aspects.registry.getAdvicesByTarget(\n                ctxt.target,\n                filter,\n                PointcutPhase.COMPILE,\n            )[PointcutPhase.COMPILE];\n            compiledSymbol = hooks.compile(ctxt, compileAdvices as CompileAdvice<T, A>[]);\n            compiled = true;\n            if (!compiledSymbol) {\n                throw new WeavingError(\n                    `${Reflect.getPrototypeOf(hooks).constructor.name}.compile() did not returned a symbol`,\n                );\n            }\n            return compiledSymbol;\n        };\n        return new _ExecutionPlan<T, A>(compileFn, linkFn);\n    }\n}\n\ntype WeaverCompile<T = unknown, A extends AdviceType = any> = (\n    ctxt: MutableAdviceContext<T, A>,\n) => A extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor;\n\ntype WeaverLink<T = unknown, A extends AdviceType = any> = (\n    ctxt: MutableAdviceContext<T, A>,\n    initialSymbol: A extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor,\n) => A extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor;\n/**\n * Sort the advices according to their precedence & store by phase & type, so they are ready to execute.\n * @internal\n */\nexport class _ExecutionPlan<T = unknown, A extends AdviceType = any> {\n    constructor(private compileFn: WeaverCompile<T, A>, private linkFn: WeaverLink<T, A>) {}\n\n    compile<C extends MutableAdviceContext<T, A>>(\n        ctxt: C,\n    ): {\n        link: () => A extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor;\n    } {\n        const compiled = this.compileFn(ctxt);\n        const link = this.linkFn;\n        return {\n            /**\n             * Returns a function that executes the plan for the Before, Around, AfterReturn, AfterThrow & After advices.\n             */\n            link: () => link(ctxt, compiled),\n        };\n    }\n}\n","import { assert } from '@aspectjs/core/utils';\n\n/**\n *\n * @param fn\n * @param name\n * @param tag\n * @param toString\n * @internal\n */\nexport function _defineFunctionProperties<T, F extends (...args: any[]) => T>(\n    fn: F,\n    name: string,\n    tag: string,\n    toString: () => string,\n): F {\n    assert(typeof fn === 'function');\n\n    // const newFn = fn;\n    const newFn = new Function('fn', `return function ${name}(...args) { return fn.apply(this, args) };`)(fn);\n    Object.defineProperty(newFn, 'name', {\n        value: name,\n    });\n    tag = tag ?? name;\n\n    Object.defineProperty(newFn, Symbol.toPrimitive, {\n        enumerable: false,\n        configurable: true,\n        value: () => tag,\n    });\n\n    newFn.prototype.toString = toString;\n    newFn.toString = toString;\n    return newFn;\n}\n","import {\n    _JoinpointFactory,\n    Advice,\n    AdviceContext,\n    AdviceError,\n    AdviceType,\n    AfterAdvice,\n    AfterReturnAdvice,\n    AfterThrowAdvice,\n    AfterThrowContext,\n    AnnotationType,\n    AroundAdvice,\n    BeforeAdvice,\n    CompileAdvice,\n    JoinPoint,\n    MutableAdviceContext,\n} from '@aspectjs/core/commons';\nimport { assert, isUndefined } from '@aspectjs/core/utils';\nimport { _WeavingStrategy } from '../../weaving-strategy';\n\n/**\n * @internal\n */\nexport abstract class _GenericWeavingStrategy<T, A extends AdviceType> implements _WeavingStrategy<T, A> {\n    after(ctxt: MutableAdviceContext<T, A>, advices: AfterAdvice<T, A>[]): void {\n        this._applyNonReturningAdvices(ctxt, advices);\n    }\n\n    afterReturn(ctxt: MutableAdviceContext<T, A>, advices: AfterReturnAdvice<T, A>[]): T {\n        ctxt.value = ctxt.value; // force key 'value' to be present\n\n        advices.forEach((advice) => {\n            ctxt.value = advice(ctxt, ctxt.value);\n        });\n\n        return ctxt.value as T;\n    }\n\n    afterThrow(ctxt: MutableAdviceContext<T, A>, advices: AfterThrowAdvice<T, A>[], allowReturn = true): any {\n        if (advices.length) {\n            ctxt.value = ctxt.value ?? undefined; // force key 'value' to be present\n            advices.forEach((advice: AfterThrowAdvice) => {\n                ctxt.advice = advice as any;\n                ctxt.value = advice(ctxt as AfterThrowContext<any, AdviceType>, ctxt.error);\n                delete ctxt.advice;\n                if (!allowReturn && !isUndefined(ctxt.value)) {\n                    throw new AdviceError(advice, `Returning from advice is not supported`);\n                }\n            });\n            return ctxt.value;\n        } else {\n            assert(!!ctxt.error);\n            // pass-trough errors by default\n            throw ctxt.error;\n        }\n    }\n\n    around(\n        ctxt: MutableAdviceContext<T, A>,\n        advices: AroundAdvice<T, A>[],\n        jp: JoinPoint<T>,\n        allowReturn = true,\n    ): JoinPoint<T> {\n        advices.reverse().forEach((advice) => {\n            const originalJp = jp;\n            const nextJp = _JoinpointFactory.create(advice, ctxt, (...args: unknown[]) => originalJp(args));\n            jp = (args: any[]) => {\n                ctxt.joinpoint = nextJp;\n                ctxt.args = args;\n                ctxt.advice = advice;\n                ctxt.value = advice(ctxt as any, nextJp, args);\n                if (ctxt.value !== undefined && !allowReturn) {\n                    throw new AdviceError(advice, `Returning from advice is not supported`);\n                }\n                return ctxt.value as T;\n            };\n        });\n\n        return jp;\n    }\n\n    before(ctxt: MutableAdviceContext<T, A>, advices: BeforeAdvice<T, A>[]): void {\n        this._applyNonReturningAdvices(ctxt, advices);\n    }\n\n    abstract compile(\n        ctxt: MutableAdviceContext<T, A>,\n        advices: CompileAdvice<T, AdviceType>[],\n    ): A extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor;\n\n    abstract initialJoinpoint(\n        ctxt: MutableAdviceContext<T, A>,\n        originalSymbol: A extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor,\n    ): void;\n\n    abstract finalize(\n        ctxt: MutableAdviceContext<T, A>,\n        joinpoint: (...args: any[]) => T,\n    ): A extends AnnotationType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor;\n\n    protected _applyNonReturningAdvices(ctxt: MutableAdviceContext<any>, advices: Advice[]) {\n        advices.forEach((advice: AfterAdvice) => {\n            ctxt.advice = advice;\n            const retVal = advice(ctxt as AdviceContext);\n            delete ctxt.advice;\n            if (!isUndefined(retVal)) {\n                throw new AdviceError(advice, `Returning from advice is not supported`);\n            }\n        });\n    }\n}\n","import {\n    _JoinpointFactory,\n    AdviceContext,\n    AdviceType,\n    AfterReturnAdvice,\n    AfterThrowAdvice,\n    AroundAdvice,\n    AroundContext,\n    CompileAdvice,\n    JoinPoint,\n    MutableAdviceContext,\n} from '@aspectjs/core/commons';\nimport { _getReferenceConstructor, _setReferenceConstructor, assert, isUndefined, Mutable } from '@aspectjs/core/utils';\nimport { _defineFunctionProperties } from '../../utils';\nimport { _GenericWeavingStrategy } from './generic-weaving-strategy';\n\n/**\n * @internal\n */\nexport class _ClassWeavingStrategy<T> extends _GenericWeavingStrategy<T, AdviceType.CLASS> {\n    private originalInstance: T;\n\n    compile(\n        ctxt: MutableAdviceContext<T, AdviceType.CLASS>,\n        advices: CompileAdvice<T, AdviceType.CLASS>[],\n    ): AdviceType.CLASS extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor {\n        // if another @Compile advice has been applied\n        // replace wrapped ctor by original ctor before it gets wrapped again\n        ctxt.target.proto.constructor = _getReferenceConstructor(ctxt.target.proto);\n        _setReferenceConstructor(ctxt.target.proto, ctxt.target.proto.constructor);\n\n        let ctor: new (...args: any[]) => T;\n        advices.forEach((advice: CompileAdvice<T, AdviceType.CLASS>) => {\n            ctxt.advice = advice;\n            ctor = advice(ctxt as AdviceContext<T, AdviceType.CLASS>) as any;\n        });\n        delete ctxt.advice;\n        return (ctxt.target.proto.constructor = ctor ?? ctxt.target.proto.constructor);\n    }\n\n    preAround(ctxt: MutableAdviceContext<T, AdviceType.CLASS>) {\n        // original ctor invocation will discard any changes done to instance before, so accessing ctxt.instance is forbidden\n        this.originalInstance = ctxt.instance;\n        ctxt.instance = null;\n    }\n\n    around(\n        ctxt: Mutable<AroundContext<T, AdviceType.CLASS>>,\n        advices: AroundAdvice<T, AdviceType.CLASS>[],\n        joinpoint: JoinPoint<T>,\n    ): (args?: any[]) => any {\n        advices.reverse().forEach((advice) => {\n            const originalJp = joinpoint;\n            const nextJp = _JoinpointFactory.create(advice, ctxt, (...args: unknown[]) => originalJp(args));\n            joinpoint = (args: any[]) => {\n                ctxt.joinpoint = nextJp;\n                ctxt.args = args;\n                ctxt.advice = advice;\n                return (ctxt.instance = advice(ctxt as any, nextJp, args) ?? ctxt.instance);\n            };\n        });\n\n        return joinpoint;\n    }\n\n    initialJoinpoint(ctxt: MutableAdviceContext<T, AdviceType.CLASS>, originalCtor: { new (...args: any[]): T }): void {\n        // We need to keep originalInstance as the instance, because of instanceof.\n        // Merge the new instance into originalInstance;\n        Object.assign(this.originalInstance, new originalCtor(...ctxt.args) ?? this.originalInstance);\n        ctxt.instance = this.originalInstance;\n    }\n\n    afterReturn<T>(\n        ctxt: MutableAdviceContext<T, AdviceType.CLASS>,\n        advices: AfterReturnAdvice<T, AdviceType.CLASS>[],\n    ): T {\n        let newInstance = ctxt.instance;\n\n        advices.forEach((advice) => {\n            ctxt.value = ctxt.instance;\n            ctxt.advice = advice;\n            newInstance = advice(ctxt, ctxt.value);\n            if (!isUndefined(newInstance)) {\n                ctxt.instance = newInstance;\n            }\n            delete ctxt.advice;\n        });\n\n        return ctxt.instance;\n    }\n\n    preAfterThrow(ctxt: MutableAdviceContext<T, AdviceType.CLASS>): void {\n        // as of ES6 classes, 'this' is no more available after ctor thrown.\n        // replace 'this' with partial this\n        ctxt.instance = this.originalInstance;\n    }\n\n    afterThrow(ctxt: MutableAdviceContext<T, AdviceType.CLASS>, advices: AfterThrowAdvice<T, AdviceType.CLASS>[]): T {\n        if (!advices.length) {\n            // pass-trough errors by default\n            throw ctxt.error;\n        } else {\n            let newInstance = ctxt.instance;\n            advices.forEach((advice) => {\n                ctxt.advice = advice;\n                newInstance = advice(ctxt, ctxt.error);\n                if (!isUndefined(newInstance)) {\n                    ctxt.instance = newInstance;\n                }\n                delete ctxt.advice;\n            });\n            return ctxt.instance;\n        }\n    }\n\n    finalize(\n        ctxt: MutableAdviceContext<T, AdviceType.CLASS>,\n        joinpoint: (...args: any[]) => T,\n    ): new (...args: any[]) => T {\n        assert(!!ctxt.target?.proto);\n        const originalCtor = ctxt.target.proto.constructor;\n        const ctorName = originalCtor.name;\n\n        joinpoint = _defineFunctionProperties(\n            joinpoint,\n            ctorName,\n            `class ${ctorName}$$advised {}`,\n            originalCtor.toString.bind(originalCtor),\n        );\n        joinpoint.prototype = ctxt.target.proto;\n        joinpoint.prototype.constructor = joinpoint;\n\n        return joinpoint as any;\n    }\n}\n","import {\n    AdviceContext,\n    AdviceError,\n    AdviceType,\n    CompileAdvice,\n    JoinPoint,\n    MutableAdviceContext,\n} from '@aspectjs/core/commons';\nimport { getOrComputeMetadata, isFunction, isUndefined } from '@aspectjs/core/utils';\nimport { _defineFunctionProperties } from '../../utils';\nimport { _GenericWeavingStrategy } from './generic-weaving-strategy';\n\ntype MethodPropertyDescriptor = PropertyDescriptor & { value: (...args: any[]) => any };\n\n/**\n * @internal\n */\nexport class _MethodWeavingStrategy<T> extends _GenericWeavingStrategy<T, AdviceType.METHOD> {\n    compile(ctxt: MutableAdviceContext<T, AdviceType.METHOD>, advices: CompileAdvice<T, AdviceType.METHOD>[]) {\n        const target = ctxt.target;\n\n        // save & restore original descriptor\n        Reflect.defineProperty(\n            target.proto,\n            target.propertyKey,\n            getOrComputeMetadata(\n                'aspectjs.originalMethodDescriptor',\n                target.proto,\n                ctxt.target.propertyKey,\n                () => {\n                    return { ...Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey) };\n                },\n                true,\n            ),\n        );\n\n        let lastCompileAdvice = advices[0];\n        let newDescriptor: PropertyDescriptor;\n\n        advices.forEach((advice) => {\n            lastCompileAdvice = advice;\n            ctxt.advice = advice;\n            newDescriptor =\n                (advice(ctxt as AdviceContext<T, AdviceType.METHOD>) as PropertyDescriptor) ?? newDescriptor;\n        });\n        delete ctxt.advice;\n\n        if (isUndefined(newDescriptor)) {\n            return Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey) as MethodPropertyDescriptor;\n        } else {\n            if (Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey)?.configurable === false) {\n                throw new AdviceError(lastCompileAdvice, `${target.label} is not configurable`);\n            }\n\n            // ensure value is a function\n            if (!isFunction(newDescriptor.value)) {\n                throw new AdviceError(\n                    lastCompileAdvice,\n                    `Expected advice to return a method descriptor. Got: ${newDescriptor.value}`,\n                );\n            }\n\n            if (isUndefined(newDescriptor.enumerable)) {\n                newDescriptor.enumerable = false;\n            }\n            if (isUndefined(newDescriptor.configurable)) {\n                newDescriptor.configurable = true;\n            }\n            // test property validity\n            newDescriptor = Object.getOwnPropertyDescriptor(\n                Object.defineProperty({}, 'surrogate', newDescriptor),\n                'surrogate',\n            );\n\n            Reflect.defineProperty(target.proto, target.propertyKey, newDescriptor);\n            return newDescriptor as MethodPropertyDescriptor;\n        }\n    }\n\n    initialJoinpoint(ctxt: MutableAdviceContext<T, AdviceType.METHOD>, refDescriptor: PropertyDescriptor): void {\n        ctxt.value = refDescriptor.value.apply(ctxt.instance, ctxt.args);\n    }\n\n    finalize(ctxt: MutableAdviceContext<T, AdviceType.METHOD>, jp: JoinPoint): PropertyDescriptor {\n        const newDescriptor: PropertyDescriptor = Object.getOwnPropertyDescriptor(\n            ctxt.target.proto,\n            ctxt.target.propertyKey,\n        );\n\n        newDescriptor.value = jp;\n\n        const originalFn = ctxt.target.proto[ctxt.target.propertyKey];\n        newDescriptor.value = _defineFunctionProperties(\n            newDescriptor.value,\n            originalFn.name,\n            originalFn.toString().split('\\n')[0],\n            originalFn.toString.bind(originalFn),\n        );\n\n        Reflect.defineMetadata('aspectjs.enhancedMethodDescriptor', true, newDescriptor);\n        return newDescriptor;\n    }\n}\n","import { AnnotationType, CompileAdvice, MutableAdviceContext } from '@aspectjs/core/commons';\nimport { getOrComputeMetadata } from '@aspectjs/core/utils';\nimport { _MethodWeavingStrategy } from './method-weaving-strategy';\n\nconst _defineProperty = Object.defineProperty;\n\nexport class _ParameterWeavingStrategy<T> extends _MethodWeavingStrategy<T> {\n    constructor() {\n        super();\n    }\n\n    compile(\n        ctxt: MutableAdviceContext<T, AnnotationType.METHOD>,\n        advices: CompileAdvice<T, AnnotationType.METHOD>[],\n    ): PropertyDescriptor & { value: (...args: any[]) => any } {\n        const target = ctxt.target;\n        // save & restore original descriptor\n        const originalDescriptor = getOrComputeMetadata(\n            'aspectjs.originalPropertyDescriptor',\n            target.proto,\n            ctxt.target.propertyKey,\n            () => {\n                return { ...Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey) };\n            },\n            true,\n        );\n\n        Reflect.defineProperty(target.proto, target.propertyKey, originalDescriptor);\n        Reflect.defineMetadata(\n            'aspectjs.originalMethodDescriptor',\n            originalDescriptor,\n            target.proto,\n            target.propertyKey,\n        );\n\n        return super.compile(ctxt, advices);\n    }\n\n    finalize(ctxt: MutableAdviceContext<T, AnnotationType.METHOD>, jp: (args?: any[]) => T): PropertyDescriptor {\n        const newDescriptor = super.finalize(ctxt, jp);\n\n        Reflect.defineProperty(ctxt.target.proto, ctxt.target.propertyKey, newDescriptor);\n\n        // We want any further method advice t use this descriptor as a reference\n        Reflect.defineMetadata(\n            'aspectjs.originalMethodDescriptor',\n            newDescriptor,\n            ctxt.target.proto,\n            ctxt.target.propertyKey,\n        );\n\n        // Override method descriptor from parameter decorator is not allowed because return value of this parameter decorators is ignored\n        // Moreover, Reflect.decorate will overwrite any changes made on proto[propertyKey]\n        // We monkey patch Object.defineProperty to prevent this;\n        Object.defineProperty = function (o: any, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>) {\n            if (o === ctxt.target.proto && p === ctxt.target.propertyKey) {\n                // restore original defineProperty method\n                Object.defineProperty = _defineProperty;\n\n                // if attempt to write an enhanced descriptor... let go\n                if (Reflect.getOwnMetadata('aspectjs.enhancedMethodDescriptor', attributes)) {\n                    return Object.defineProperty(o, p, attributes);\n                } else {\n                    // prevent writing back old descriptor\n                    return newDescriptor;\n                }\n            }\n\n            return _defineProperty(o, p, attributes);\n        };\n\n        return newDescriptor as any;\n    }\n}\n","import {\n    _JoinpointFactory,\n    AdviceError,\n    AdviceTarget,\n    AdviceType,\n    AnnotationType,\n    CompileAdvice,\n    MutableAdviceContext,\n} from '@aspectjs/core/commons';\nimport { assert, getOrComputeMetadata, isFunction, isUndefined, Mutable } from '@aspectjs/core/utils';\nimport { _GenericWeavingStrategy } from './generic-weaving-strategy';\n\n/**\n * @internal\n */\nexport class _PropertyGetWeavingStrategy<T> extends _GenericWeavingStrategy<T, AdviceType.PROPERTY> {\n    private compiledDescriptor: PropertyDescriptor;\n\n    compile(\n        ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>,\n        advices: CompileAdvice<T, AdviceType.PROPERTY>[],\n    ): AdviceType.PROPERTY extends AdviceType.METHOD\n        ? () => T\n        : AdviceType.PROPERTY extends AdviceType.CLASS\n        ? { new (...args: any[]): T }\n        : PropertyDescriptor {\n        const target = ctxt.target;\n        if (this.compiledDescriptor) {\n            return this.compiledDescriptor;\n        }\n\n        // if another @Compile advice has been applied\n        // replace wrapped descriptor by original descriptor before it gets wrapped again\n        (target as Mutable<AdviceTarget>).descriptor = getOrComputeMetadata(\n            'aspectjs.originalDescriptor',\n            target.proto,\n            target.propertyKey,\n            () => {\n                return (\n                    Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey) ?? {\n                        configurable: true,\n                        enumerable: true,\n                        get() {\n                            return Reflect.getOwnMetadata(`aspectjs.propValue`, this, target.propertyKey);\n                        },\n                        set(value: any) {\n                            Reflect.defineMetadata(`aspectjs.propValue`, value, this, target.propertyKey);\n                        },\n                    }\n                );\n            },\n            true,\n        );\n\n        let advice: CompileAdvice<T, AdviceType.PROPERTY>;\n        let newDescriptor: PropertyDescriptor = ctxt.target.descriptor;\n\n        advices.forEach((advice) => {\n            ctxt.advice = advice;\n            newDescriptor = advice(ctxt) ?? newDescriptor;\n        });\n        delete ctxt.advice;\n\n        if (newDescriptor) {\n            if (Reflect.getOwnPropertyDescriptor(target.proto, target.propertyKey)?.configurable === false) {\n                throw new AdviceError(advice, `${target.label} is not configurable`);\n            }\n\n            // test property validity\n            const surrogate = { prop: '' };\n            const surrogateProp = Reflect.getOwnPropertyDescriptor(surrogate, 'prop');\n            if (isUndefined(newDescriptor.enumerable)) {\n                newDescriptor.enumerable = surrogateProp.enumerable;\n            }\n\n            if (isUndefined(newDescriptor.configurable)) {\n                newDescriptor.configurable = surrogateProp.configurable;\n            }\n\n            // normalize the descriptor\n            newDescriptor = Object.getOwnPropertyDescriptor(\n                Object.defineProperty(surrogate, 'newProp', newDescriptor),\n                'newProp',\n            );\n\n            Reflect.defineProperty(target.proto, target.propertyKey, newDescriptor);\n        }\n\n        if ((newDescriptor as Record<string, any>).hasOwnProperty('value')) {\n            const propValue = newDescriptor.value;\n            newDescriptor.get = () => propValue;\n            delete newDescriptor.writable;\n            delete newDescriptor.value;\n        }\n\n        return (this.compiledDescriptor = newDescriptor);\n    }\n\n    preBefore(ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>): void {\n        ctxt.args = [];\n    }\n\n    initialJoinpoint(ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>, originalDescriptor: PropertyDescriptor): void {\n        assert(isFunction(originalDescriptor.get));\n        ctxt.value = _JoinpointFactory.create(null, ctxt, originalDescriptor.get)();\n    }\n\n    finalize(\n        ctxt: MutableAdviceContext<T, AnnotationType.PROPERTY>,\n        joinpoint: (...args: any[]) => T,\n    ): AnnotationType.PROPERTY extends AnnotationType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor {\n        const newDescriptor = {\n            ...this.compiledDescriptor,\n            get: joinpoint,\n        };\n\n        // test property validity\n        Object.getOwnPropertyDescriptor(Object.defineProperty({}, 'surrogate', newDescriptor), 'surrogate');\n\n        return newDescriptor;\n    }\n}\n","import {\n    _JoinpointFactory,\n    AdviceType,\n    AfterAdvice,\n    AfterReturnAdvice,\n    AfterThrowAdvice,\n    AnnotationType,\n    AroundAdvice,\n    JoinPoint,\n    MutableAdviceContext,\n} from '@aspectjs/core/commons';\nimport { assert, isFunction } from '@aspectjs/core/utils';\nimport { _GenericWeavingStrategy } from './generic-weaving-strategy';\nimport { _PropertyGetWeavingStrategy } from './property-get-weaving-strategy';\n\n/**\n * @internal\n */\nexport class _PropertySetWeavingStrategy<T> extends _GenericWeavingStrategy<T, AdviceType.PROPERTY> {\n    private compiledDescriptor: PropertyDescriptor;\n\n    constructor(private getterHooks: _PropertyGetWeavingStrategy<T>) {\n        super();\n    }\n\n    compile(\n        ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>,\n    ): AdviceType.PROPERTY extends AdviceType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor {\n        return (this.compiledDescriptor = this.getterHooks.compile(ctxt, null));\n    }\n\n    initialJoinpoint(ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>, refDescriptor: PropertyDescriptor): void {\n        assert(isFunction(refDescriptor?.set));\n        ctxt.value = _JoinpointFactory.create(null, ctxt, refDescriptor.set)(ctxt.args);\n    }\n\n    around(\n        ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>,\n        advices: AroundAdvice<T, AdviceType.PROPERTY>[],\n        jp: JoinPoint<T>,\n    ): JoinPoint<T> {\n        return super.around(ctxt, advices, jp, false);\n    }\n\n    afterReturn(\n        ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>,\n        advices: AfterReturnAdvice<T, AdviceType.PROPERTY>[],\n    ): any {\n        return this._applyNonReturningAdvices(ctxt, advices);\n    }\n\n    afterThrow(\n        ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>,\n        advices: AfterThrowAdvice<T, AdviceType.PROPERTY>[],\n    ): any {\n        super.afterThrow(ctxt, advices, false);\n    }\n\n    after(ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>, advices: AfterAdvice<T, AdviceType.PROPERTY>[]): void {\n        this._applyNonReturningAdvices(ctxt, advices);\n    }\n\n    finalize(\n        ctxt: MutableAdviceContext<T, AnnotationType.PROPERTY>,\n        joinpoint: (...args: any[]) => T,\n    ): AnnotationType.PROPERTY extends AnnotationType.CLASS ? { new (...args: any[]): T } : PropertyDescriptor {\n        const newDescriptor = {\n            ...this.compiledDescriptor,\n            set: joinpoint,\n        };\n\n        // test property validity\n        Object.getOwnPropertyDescriptor(Object.defineProperty({}, 'surrogate', newDescriptor), 'surrogate');\n\n        return newDescriptor;\n    }\n}\n","import {\n    Advice,\n    AdviceTarget,\n    AdviceType,\n    AnnotationsBundle,\n    AnnotationTarget,\n    AnnotationType,\n    AspectType,\n    JoinPoint,\n    MutableAdviceContext,\n    Pointcut,\n    Weaver,\n    WeaverContext,\n    WeaverProfile,\n    WeavingError,\n} from '@aspectjs/core/commons';\nimport { isFunction } from '@aspectjs/core/utils';\nimport { _AdviceExecutionPlanFactory } from '../plan.factory';\nimport { _ClassWeavingStrategy } from './strategies/class-weaving-strategy';\nimport { _MethodWeavingStrategy } from './strategies/method-weaving-strategy';\nimport { _ParameterWeavingStrategy } from './strategies/parameter-weaving-strategy';\nimport { _PropertyGetWeavingStrategy } from './strategies/property-get-weaving-strategy';\nimport { _PropertySetWeavingStrategy } from './strategies/property-set-weaving-strategy';\n\n/**\n * The JitWeaver wires up advices to the corresponding annotations as soon as the annotation gets processed by JS interpreter.\n * @public\n */\nexport class JitWeaver extends WeaverProfile implements Weaver {\n    private _planFactory: _AdviceExecutionPlanFactory;\n    private _enhancers = {\n        [AnnotationType.CLASS]: this._enhanceClass.bind(this),\n        [AnnotationType.PROPERTY]: this._enhanceProperty.bind(this),\n        [AnnotationType.METHOD]: this._enhanceMethod.bind(this),\n        [AnnotationType.PARAMETER]: this._enhanceParameter.bind(this),\n    };\n    /**\n     *\n     * @param _context - the weaver context to attach this weaver to.\n     * @param _prod - When prod mode is activated, enabling an aspect after Annotation compilation is prohibed.\n     */\n    constructor(private _context: WeaverContext, private _prod = true) {\n        super();\n        this._planFactory = new _AdviceExecutionPlanFactory();\n    }\n\n    enable(...aspects: (AspectType | WeaverProfile)[]): this {\n        const _aspects = new WeaverProfile().enable(...aspects).getAspects();\n        try {\n            this._context.aspects.registry.register(..._aspects);\n            if (this._prod) {\n                // check annotations has not already been processed\n                const alreadyProcessedAnnotations = new Map<Pointcut, AspectType>();\n                _aspects.forEach((aspect) => {\n                    this._context.aspects.registry\n                        .getAdvicesByAspect(aspect)\n                        .forEach((a) => alreadyProcessedAnnotations.set(a.pointcut, aspect));\n                });\n\n                alreadyProcessedAnnotations.forEach((aspect: AspectType, pointcut: Pointcut) => {\n                    if (this._context.annotations.bundle.all(pointcut.annotation.ref).length) {\n                        throw new WeavingError(\n                            `Cannot enable aspect ${aspect.constructor?.name ?? aspect} because annotation ${\n                                pointcut.annotation\n                            } has already been applied`,\n                        );\n                    }\n                });\n            }\n\n            const r = super.enable(..._aspects);\n            _aspects.filter((a) => isFunction(a.onEnable)).forEach((a) => a.onEnable.call(a, this));\n\n            return r;\n        } catch (e) {\n            this._context.aspects.registry.remove(..._aspects);\n            throw e;\n        }\n    }\n\n    disable(...aspects: (AspectType | WeaverProfile)[]): this {\n        const _aspects = new WeaverProfile().enable(...aspects).getAspects();\n        _aspects.filter((a) => isFunction(a.onDisable)).forEach((a) => a.onEnable.call(a, this));\n\n        return super.disable(..._aspects);\n    }\n\n    reset(): this {\n        this._planFactory = new _AdviceExecutionPlanFactory();\n        return super.reset();\n    }\n\n    enhance<T>(target: AnnotationTarget<T>): void | Function | PropertyDescriptor {\n        const ctxt = new AdviceContextImpl(target, this._context.annotations.bundle.at(target.location));\n\n        return this._enhancers[target.type](ctxt);\n    }\n\n    private _enhanceClass<T>(ctxt: MutableAdviceContext<T, AdviceType.CLASS>): new (...args: any[]) => T {\n        const plan = this._planFactory.create(ctxt.target, new _ClassWeavingStrategy());\n        return plan.compile(ctxt).link();\n    }\n\n    private _enhanceProperty<T>(ctxt: MutableAdviceContext<T, AdviceType.PROPERTY>): PropertyDescriptor {\n        const getterHooks = new _PropertyGetWeavingStrategy();\n        const gettersPlan = this._planFactory.create(ctxt.target, getterHooks, {\n            name: 'get',\n            fn: _isPropertyGet,\n        });\n\n        const newDescriptor = gettersPlan.compile(ctxt).link();\n\n        if (_isDescriptorWritable(newDescriptor)) {\n            const settersPlan = this._planFactory.create(ctxt.target, new _PropertySetWeavingStrategy(getterHooks), {\n                name: 'set',\n                fn: _isPropertySet,\n            });\n\n            newDescriptor.set = settersPlan.compile(ctxt).link().set;\n            delete newDescriptor.writable;\n        } else {\n            delete newDescriptor.set;\n        }\n\n        const target = ctxt.target;\n        Reflect.defineProperty(target.proto, target.propertyKey, newDescriptor);\n\n        return newDescriptor;\n    }\n\n    private _enhanceMethod<T>(ctxt: MutableAdviceContext<T, AdviceType.METHOD>): PropertyDescriptor {\n        const plan = this._planFactory.create(ctxt.target, new _MethodWeavingStrategy());\n        return plan.compile(ctxt).link();\n    }\n\n    private _enhanceParameter<T>(ctxt: MutableAdviceContext<T, AdviceType.METHOD>): PropertyDescriptor {\n        const plan = this._planFactory.create(ctxt.target, new _ParameterWeavingStrategy());\n        return plan.compile(ctxt).link();\n    }\n}\n\nfunction _isPropertyGet(a: Advice) {\n    return a.pointcut.ref.startsWith('property#get');\n}\n\nfunction _isPropertySet(a: Advice) {\n    return a.pointcut.ref.startsWith('property#set');\n}\n\nfunction _isDescriptorWritable(propDescriptor: PropertyDescriptor) {\n    const desc = propDescriptor as Record<string, any>;\n    return !desc || (desc.hasOwnProperty('writable') && desc.writable) || isFunction(desc.set);\n}\n\nclass AdviceContextImpl<T, A extends AdviceType> implements MutableAdviceContext<unknown, A> {\n    public advice: Advice<T, A>;\n    public error: Error;\n    public instance: T;\n    public value: T | unknown;\n    public args: any[];\n    public joinpoint: JoinPoint;\n    public target: AdviceTarget<T, A>;\n    public data: Record<string, any>;\n    public annotations: AnnotationsBundle;\n\n    constructor(target: AdviceTarget<any, A>, bundle: AnnotationsBundle<T>) {\n        this.target = target;\n        this.data = {};\n        this.annotations = bundle;\n    }\n\n    clone(): this {\n        return Object.assign(Object.create(Reflect.getPrototypeOf(this)) as MutableAdviceContext<unknown, A>, this);\n    }\n\n    toString(): string {\n        return `${this.advice} on ${this.target.label}`;\n    }\n}\n","import {\n    AnnotationBundleRegistry,\n    AnnotationLocationFactory,\n    AnnotationRegistry,\n    AnnotationTargetFactory,\n    AspectsRegistry,\n    RootAnnotationsBundle,\n    Weaver,\n    WeaverContext,\n} from '@aspectjs/core/commons';\nimport { AspectsRegistryImpl } from '../aspect/aspect.registry.impl';\nimport { JitWeaver } from './jit/jit-weaver';\n\nconst bundleRegistry: AnnotationBundleRegistry = {\n    byTargetClassRef: {},\n    byAnnotation: {},\n};\n\nconst bundle = new RootAnnotationsBundle(bundleRegistry);\nconst annotationRegistry = new AnnotationRegistry(bundleRegistry);\n/**\n * @public\n */\nexport class WeaverContextImpl implements WeaverContext {\n    readonly weaver: Weaver;\n    private readonly _targetFactory = new AnnotationTargetFactory();\n\n    readonly aspects: { registry: AspectsRegistry };\n\n    readonly annotations = {\n        location: new AnnotationLocationFactory(this._targetFactory),\n        registry: annotationRegistry,\n        targetFactory: this._targetFactory,\n        bundle,\n    };\n\n    constructor() {\n        this.aspects = {\n            registry: new AspectsRegistryImpl(this),\n        };\n\n        this.weaver = this._createWeaver();\n    }\n\n    protected _createWeaver(): Weaver {\n        return new JitWeaver(this);\n    }\n    /**\n     * Get the global weaver\n     */\n    getWeaver(): Weaver {\n        return this.weaver;\n    }\n}\n","import {\n    AnnotationLocationFactory,\n    AnnotationRegistry,\n    AnnotationTargetFactory,\n    _getWeaverContext,\n    RootAnnotationsBundle,\n    _setWeaverContext,\n    Weaver,\n    WeaverContext,\n    AspectsRegistry,\n} from '@aspectjs/core/commons';\nimport { WeaverContextImpl } from './weaver/weaver-context.impl';\n\n// TODO remove when https://github.com/microsoft/rushstack/issues/1050 is resolved\nlet _AspectsRegistry: AspectsRegistry;\nAnnotationLocationFactory;\nAnnotationRegistry;\nAnnotationTargetFactory;\nRootAnnotationsBundle;\n/**\n * @public\n */\nexport const WEAVER_CONTEXT = new (class implements WeaverContext {\n    // Allow setWeaverContext to switch implementation of weaver.\n    // This is used for resetWaverContext as a convenience for tests\n    get aspects() {\n        return _getWeaverContext().aspects;\n    }\n    get annotations() {\n        return _getWeaverContext().annotations;\n    }\n\n    getWeaver(): Weaver {\n        return _getWeaverContext().getWeaver();\n    }\n})();\n_setWeaverContext(new WeaverContextImpl());\n"],"names":["assert","AdviceError","_getReferenceConstructor","getOrComputeMetadata"],"mappings":"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"}