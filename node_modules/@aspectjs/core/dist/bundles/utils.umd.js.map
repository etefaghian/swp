{"version":3,"file":"utils.umd.js","sources":["../../utils/src/utils.ts","../../utils/src/locator.ts"],"sourcesContent":["let __debug = false;\n\n/**\n * @public\n */\nexport interface AspectOptions {\n    id?: string;\n}\n/**\n * @public\n */\nexport type Mutable<T> = {\n    -readonly [K in keyof T]: T[K];\n};\nconst ASPECT_OPTIONS_REFLECT_KEY = 'aspectjs.aspect.options';\nconst ASPECT_ORIGINAL_CTOR_KEY = 'aspectjs.referenceConstructor';\n\n/**\n * @public\n */\nexport function _getReferenceConstructor(proto: object & { constructor: { new (...args: unknown[]): unknown } }) {\n    return Reflect.getOwnMetadata(ASPECT_ORIGINAL_CTOR_KEY, proto) ?? proto.constructor;\n}\n\n/**\n * @public\n */\nexport function _setReferenceConstructor<T>(proto: object, originalCtor: { new (...args: any[]): T }) {\n    assert(isFunction(originalCtor));\n    Reflect.defineMetadata(ASPECT_ORIGINAL_CTOR_KEY, originalCtor, proto);\n}\n\n/**\n * @public\n */\nexport function isAspect(aspect: object | Function) {\n    return !!__getAspectOptions(aspect);\n}\n\n/**\n * @public\n */\nexport function assertIsAspect(aspect: object | Function) {\n    if (!isAspect(aspect)) {\n        const proto = getProto(aspect);\n        throw new TypeError(`${proto.constructor.name} is not an Aspect`);\n    }\n}\n\nfunction __getAspectOptions(aspect: object | Function): AspectOptions {\n    if (!aspect) {\n        return;\n    }\n    const proto = getProto(aspect);\n    if (proto) {\n        return Reflect.getOwnMetadata(ASPECT_OPTIONS_REFLECT_KEY, proto);\n    }\n}\n/**\n * @public\n */\nexport function getAspectOptions(aspect: object | Function): AspectOptions {\n    assertIsAspect(aspect);\n    return __getAspectOptions(aspect);\n}\n\n/**\n * @public\n */\nexport function setAspectOptions(target: Function, options: AspectOptions): void {\n    Reflect.defineMetadata(ASPECT_OPTIONS_REFLECT_KEY, options, getProto(target));\n}\n\n/**\n * @internal\n */\nexport function __setDebug(debug: boolean) {\n    __debug = debug;\n}\n\n/**\n * @public\n */\nexport function assert(condition: boolean, errorProvider?: () => Error): void;\n\n/**\n * @public\n */\nexport function assert(condition: boolean, msg?: string): void;\n\n/**\n * @public\n */\nexport function assert(condition: boolean, msg?: string | (() => Error)) {\n    if (__debug && !condition) {\n        debugger;\n        const e = isFunction(msg) ? (msg as Function)() : new Error(msg ?? 'assertion error');\n        const stack = e.stack.split('\\n');\n        stack.splice(1, 1);\n        e.stack = stack.join('\\n');\n\n        throw e;\n    }\n}\n\n/**\n * @public\n */\nexport function getOrComputeMetadata<T>(key: string, target: object, valueGenerator: () => T, save?: boolean): T;\n\n/**\n * @public\n */\nexport function getOrComputeMetadata<T>(\n    key: string,\n    target: object,\n    propertyKey: string,\n    valueGenerator: () => T,\n    save?: boolean,\n): T;\nexport function getOrComputeMetadata<T>(\n    key: string,\n    target: object,\n    propertyKey: string | (() => T),\n    valueGenerator?: (() => T) | boolean,\n    save = true,\n): T {\n    let _propertyKey = propertyKey as string;\n    let _valueGenerator = valueGenerator as () => T;\n    if (typeof valueGenerator === 'boolean') {\n        save = valueGenerator;\n    }\n    if (typeof propertyKey === 'function') {\n        _valueGenerator = propertyKey;\n        _propertyKey = undefined;\n    }\n\n    assert(!!target);\n    let value = Reflect.getOwnMetadata(key, target, _propertyKey);\n    if (isUndefined(value)) {\n        value = _valueGenerator();\n        if (save) {\n            Reflect.defineMetadata(key, value, target, _propertyKey);\n        }\n    }\n\n    return value;\n}\n\n/**\n * @public\n */\nexport function getProto(\n    target: Record<string, any> | Function,\n): Record<string, any> & { constructor?: new (...args: any[]) => any } {\n    if (isFunction(target)) {\n        return target.prototype;\n    } else if (target === null || target === undefined) {\n        return target as any;\n    }\n    return target.hasOwnProperty('constructor') ? target : Object.getPrototypeOf(target);\n}\n\n/**\n * @public\n */\nexport function isObject(value: any): value is object {\n    return typeof value === 'object' && !isArray(value);\n}\n\n/**\n * @public\n */\nexport function isArray(value: any): value is any[] {\n    return !isUndefined(value) && value !== null && Object.getPrototypeOf(value) === Array.prototype;\n}\n\n/**\n * @public\n */\nexport function isString(value: any): value is string {\n    return typeof value === 'string';\n}\n\n/**\n * @public\n */\nexport function isUndefined(value: any): value is undefined {\n    return typeof value === 'undefined';\n}\n\n/**\n * @public\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n    return typeof value === 'function';\n}\n\n/**\n * @public\n */\nexport function isNumber(value: any): value is number {\n    return typeof value === 'number';\n}\n\n/**\n * @public\n */\nexport function isEmpty(value: any): boolean {\n    return value.length === 0;\n}\n\n/**\n * @public\n */\nexport function isPromise(obj: any): obj is Promise<any> {\n    return isFunction(obj?.then);\n}\n","/**\n * Null-safe navigation through object properties, that allows to generate missing properties on the fly.\n *\n * @public\n */\nexport class Locator<U> {\n    constructor(private _obj: U, private _parent?: Locator<any>, private _parentKey?: string | number | symbol) {}\n\n    /**\n     * Descend to the given property of the object.\n     * @param propertyName - the property to access to.\n     */\n    at<K extends keyof U>(propertyName: K): Locator<U[K]> {\n        return new Locator(this._obj ? this._obj[propertyName] : undefined, this, propertyName);\n    }\n\n    /**\n     * Get the property value\n     * @returns the property value (can be null)\n     */\n    get(): U {\n        return this._obj;\n    }\n\n    /**\n     * Get the property value, or generate a new one with the given function.\n     * The generated property is then saved into the object.\n     * @param valueProvider - the function used to generate a new value\n     * @returns the property value\n     */\n    orElseCompute(valueProvider: () => U): U {\n        return this.orElse(valueProvider, true);\n    }\n\n    /**\n     * Get the property value, or generate a new one with the given function.\n     * The generated property is **not** saved into the object.\n     * @param valueProvider - the function used to generate a new value\n     * @returns the property value\n     */\n    orElseGet(valueProvider: () => U): U {\n        return this.orElse(valueProvider, false);\n    }\n\n    /**\n     * Get the property value, or generate a new one with the given function.\n     * @param valueProvider - the function used to generate a new value\n     * @param save - if the generated property should then be saved into the object.\n     * @returns the property value\n     */\n    orElse(valueProvider: () => U, save = true): U {\n        const value = this._obj ?? valueProvider();\n        if (save) {\n            this._obj = value;\n            this._parent._patch(value, this._parentKey);\n        }\n        return value;\n    }\n\n    private _patch<K extends keyof U>(value: U[K], key: K) {\n        if (!this._obj) {\n            this._obj = {} as U;\n            if (this._parent) {\n                this._parent._patch(this._obj, this._parentKey);\n            }\n        }\n        this._obj[key] = value;\n    }\n}\n\n/**\n * @param obj - the object to navigate through.\n *\n * @public\n */\nexport function locator<U = unknown>(obj: U) {\n    return new Locator(obj);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA,IAAI,OAAO,GAAG,KAAd;mCA4BmC;;EAInC;;EAEG;;EACG,SAAU,wBAAV,MAAA;;;EACF,SAAA,CAAA,EAAA,GAAO,sBAAA,yBAAA,OAAA,CAAP,UAAA,iBAAA,KAAA,oBAAA;EACH;;;;;;sBAOqB;2BACK,0BAA0B;;EAIrD;;;;;EAII,qCAAA;;;;;;;;;gBASc;;EAEjB;;;;;;;;;;;;;;;;;;;;;;;;;;4BAmCgC;;;EAqBjC;;;;;;;;;;;;;;;EAmCQ,aAAW,sBAAX;EACA,IAAA,YAAA,CAAa,CAAb,GAAA;;EAEA,WAAA;EACH;;EAqBC,SAAU,oBAAV,CACF,GADE,QAAA,aAAA,gBAAA;;EAQF,qBAAmB,WAAnB;;;;;;;;qBAOmB;;;;;gBAMP,QAAQ,cAAR,IAAA,QAAA,cAAA;;EACZ,wBAAA,EAAwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EC1M5B;;;;EAIG;MACU,OAAb;EACI,uBAAA,EAA0G,OAA1G,YAAA;;;;EAA0G,SAAA,OAAA,GAAA,OAAA;;;;;;;;;EAD9G;EAAA;EAAA,mCAAA;;;;;;;;EAAA;EAAA;EAAA;;;EAiBI;;;;;;;EAjBJ;EAAA;EAAA,+CAAA;;;EA6BI;;;;;EAKG;;EAlCP;EAAA;EAAA,8BAmCc,aAnCd;EAoCQ,aAAO,KAAK,MAAL,CAAY,aAAZ,EAA2B,KAA3B,CAAP;EACH;;;;;;;;EArCL;EAAA;EAAA,wCAAA;;;;;EA8CQ,UAAM,KAAK,GAAA,CAAA,EAAA,YAAA,UAAA,iBAAA,KAAA,kBAAX;;EACA,UAAI,IAAJ,EAAU;EACN,aAAK,IAAL,GAAY,KAAZ;;EACA,aAAK,OAAL,CAAa,MAAb,CAAoB,KAApB,EAA2B,KAAK,UAAhC;EACH;;EACD,aAAO,KAAP;EACH;EApDL;EAAA;EAAA,gCAAA,KAAA;YAwDY,YAAY;EACZ,iBAAA,KAAA;;cACI,KAAK;;;;;;;EA1DrB;;EAAA;EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}